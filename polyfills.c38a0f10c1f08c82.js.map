{"version":3,"file":"polyfills.c38a0f10c1f08c82.js","mappings":"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","names":["__defProp","Object","defineProperty","__defProps","defineProperties","__getOwnPropDescs","getOwnPropertyDescriptors","__getOwnPropSymbols","getOwnPropertySymbols","__hasOwnProp","prototype","hasOwnProperty","__propIsEnum","propertyIsEnumerable","__defNormalProp","obj","key","value","enumerable","configurable","writable","__spreadValues","a","b","prop","call","__publicField","global","globalThis","__symbol__","name","__Zone_symbol_prefix","ObjectGetOwnPropertyDescriptor","getOwnPropertyDescriptor","ObjectDefineProperty","ObjectGetPrototypeOf","getPrototypeOf","ObjectCreate","create","ArraySlice","Array","slice","ADD_EVENT_LISTENER_STR","REMOVE_EVENT_LISTENER_STR","ZONE_SYMBOL_ADD_EVENT_LISTENER","ZONE_SYMBOL_REMOVE_EVENT_LISTENER","TRUE_STR","FALSE_STR","ZONE_SYMBOL_PREFIX","wrapWithCurrentZone","callback","source","Zone","current","wrap","scheduleMacroTaskWithCurrentZone","data","customSchedule","customCancel","scheduleMacroTask","zoneSymbol","isWindowExists","window","internalWindow","_global","bindArguments","args","i","length","isPropertyWritable","propertyDesc","get","set","isWebWorker","WorkerGlobalScope","self","isNode","process","toString","isBrowser","HTMLElement","isMix","zoneSymbolEventNames","enableBeforeunloadSymbol","wrapFn","event","eventNameSymbol","type","target","this","listener","result","message","filename","lineno","colno","error","preventDefault","apply","arguments","returnValue","patchProperty","desc","onPropPatchedSymbol","originalDescGet","originalDescSet","eventName","newValue","removeEventListener","addEventListener","removeAttribute","patchOnProperties","properties","onProperties","push","j","originalInstanceKey","patchClass","className","OriginalClass","Error","attachOriginToPatched","instance","prop2","fn","patchMethod","patchFn","proto","delegateName","delegate","patchDelegate","patchMacroTask","funcName","metaCreator","setNative","scheduleTask","task","cbIdx","invoke","self2","meta","patched","original","isFunction","isNumber","OPTIMIZED_ZONE_EVENT_TASK_DATA","useG","zoneSymbolEventNames2","globalSources","EVENT_NAME_SYMBOL_REGX","RegExp","IMMEDIATE_PROPAGATION_SYMBOL","prepareEventNames","eventNameToString","falseEventName","trueEventName","symbol","symbolCapture","patchEventTarget","_global2","api","apis","patchOptions","ADD_EVENT_LISTENER","add","REMOVE_EVENT_LISTENER","rm","LISTENERS_EVENT_LISTENER","listeners","REMOVE_ALL_LISTENERS_EVENT_LISTENER","rmAll","zoneSymbolAddEventListener","ADD_EVENT_LISTENER_SOURCE","PREPEND_EVENT_LISTENER","PREPEND_EVENT_LISTENER_SOURCE","invokeTask","isRemoved","handleEvent","event2","originalDelegate","err","options","once","globalCallback","context","isCapture","tasks","errors","copyTasks","nativeScheduleMicroTask","globalZoneAwareCallback","globalZoneAwareCaptureCallback","patchEventTargetMethods","patchOptions2","useGlobalCallback","validateHandler","vh","checkDuplicate","chkDup","returnTarget","rt","taskData","nativeAddEventListener","nativeRemoveEventListener","nativeListeners","nativeRemoveAllListeners","nativePrependEventListener","prepend","isExisting","capture","symbolEventNames","symbolEventName","existingTasks","splice","removeAbortListener","allRemoved","compare","diff","typeOfDelegate","unpatchedEvents","passiveEvents","makeAddListener","nativeListener","addSource","customScheduleFn","customCancelFn","returnTarget2","transferEventName","isEventListenerObject","passive","indexOf","copyEventListenerOptions","newOptions","signal","buildEventListenerOptions","__spreadProps","aborted","zone","constructorName","constructor","targetSource","scheduleEventTask","onAbort","cancelTask","unshift","existingTask","findEventTasks","captureTasks","removeTasks","keys","match","exec","evtName","results","foundTasks","captureFalseTasks","captureTrueTasks","concat","patchEventPrototype","global2","Event","taskSymbol","patchTimer","window2","setName","cancelName","nameSuffix","clearNative","tasksByHandleId","handleOrId","handleId","handle","isRefreshable","refresh","clearTask","_a","isPeriodic","delay","handle2","handleId2","isPeriodic2","isRefreshable2","originalRefresh","state","_state","_updateTaskCount","id","cancelFn","filterProperties","ignoreProperties","tip","filter","ip","targetIgnoreProperties","op","patchFilteredProperties","getOnEventNames","getOwnPropertyNames","startsWith","map","substring","patchCallbacks","targetName","method","callbacks","nativeDelegate","opts","forEach","descriptor","_redefineProperty","Zone2","loadZone","initZone","performance","mark","performanceMeasure","label","measure","_ZoneImpl","parent","zoneSpec","_parent","_name","_properties","_zoneDelegate","_ZoneDelegate","assertZonePatched","Promise","patches","ZoneAwarePromise","root","_currentZoneFrame","currentTask","_currentTask","__load_patch","ignoreDuplicate","perfName","_api","getZoneWith","fork","_callback","intercept","runGuarded","run","applyThis","applyArgs","handleError","runTask","NO_ZONE","zoneTask","notScheduled","eventTask","macroTask","reEntryGuard","running","_transitionTo","scheduled","previousTask","unknown","scheduling","zoneDelegates","_zoneDelegates","newZone","_zone","scheduleMicroTask","ZoneTask","microTask","canceling","runCount","count","ZoneImpl","DELEGATE_ZS","onHasTask","_","hasTaskState","hasTask","onScheduleTask","onInvokeTask","onCancelTask","parentDelegate","_parentDelegate","_forkZS","onFork","_forkDlgt","_forkCurrZone","_interceptZS","onIntercept","_interceptDlgt","_interceptCurrZone","_invokeZS","onInvoke","_invokeDlgt","_invokeCurrZone","_handleErrorZS","onHandleError","_handleErrorDlgt","_handleErrorCurrZone","_scheduleTaskZS","_scheduleTaskDlgt","_scheduleTaskCurrZone","_invokeTaskZS","_invokeTaskDlgt","_invokeTaskCurrZone","_cancelTaskZS","_cancelTaskDlgt","_cancelTaskCurrZone","_hasTaskZS","_hasTaskDlgt","_hasTaskDlgtOwner","_hasTaskCurrZone","zoneSpecHasTask","targetZone","returnTask","scheduleFn","isEmpty","counts","_taskCounts","prev","next","change","_numberOfNestedTaskFrames","drainMicroTaskQueue","cancelScheduleRequest","toState","fromState1","fromState2","toJSON","symbolSetTimeout","symbolPromise","symbolThen","nativeMicroTaskQueuePromise","_microTaskQueue","_isDrainingMicrotaskQueue","func","resolve","nativeThen","then","queue","onUnhandledError","microtaskDrainDone","currentZoneFrame","noop","showUncaughtError","patchThen","getGlobalObjects","patchCommon","Zone3","patchPromise","Zone4","ObjectGetOwnPropertyDescriptor2","ObjectDefineProperty2","__symbol__2","_uncaughtPromiseErrors","isDisableWrappingUncaughtPromiseRejection","e","rejection","console","stack","uncaughtPromiseError","shift","throwOriginal","handleUnhandledRejection","UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL","handler","isThenable","forwardResolution","forwardRejection","reject","symbolState","symbolValue","symbolFinally","symbolParentPromiseValue","symbolParentPromiseState","UNRESOLVED","RESOLVED","REJECTED","makeResolver","promise","v","resolvePromise","wasCalled","wrappedFunction","TYPE_ERROR","CURRENT_TASK_TRACE_SYMBOL","onceWrapper","TypeError","clearRejectedNoCatch","trace","scheduleResolveOrReject","readableObjectToString","JSON","stringify","REJECTION_HANDLED_HANDLER","chainPromise","onFulfilled","onRejected","promiseState","parentPromiseValue","isFinallyPromise","AggregateError","withResolvers","res","rej","any","values","Symbol","iterator","promises","finished","race","onResolve","onReject","all","allWithCallback","allSettled","thenCallback","status","errorCallback","reason","unresolvedCount","valueIndex","resolvedValues","curValueIndex","value2","thenErr","executor","toStringTag","species","C","catch","finally","onFinally","NativePromise","symbolThenPatched","Ctor","originalThen","zoneify","resultPromise","ctor","patchToString","originalFunctionToString","Function","ORIGINAL_DELEGATE_SYMBOL","PROMISE_SYMBOL","ERROR_SYMBOL","newFunctionToString","nativePromise","nativeError","originalObjectToString","patchUtil","eventNames","SYMBOL_BLACK_LISTED_EVENTS","SYMBOL_UNPATCHED_EVENTS","patchBrowser","clear","blockingMethods","name2","s","patchEvent","eventTargetPatch","zoneSymbolEventNames3","TRUE_STR2","FALSE_STR2","ZONE_SYMBOL_PREFIX2","EVENT_TARGET","EventTarget","XMLHttpRequestEventTarget","propertyDescriptorPatch","__Zone_ignore_on_properties","patchTargets","internalWindow2","patchCustomElements","isBrowser2","isMix2","customElements","patchXHR","XMLHttpRequest","XMLHttpRequestPrototype","oriAddListener","oriRemoveListener","XMLHttpRequestEventTargetPrototype","READY_STATE_CHANGE","SCHEDULED","XHR_SCHEDULED","XHR_ERROR_BEFORE_SCHEDULED","XHR_LISTENER","newListener","readyState","DONE","loadTasks","oriInvoke","loadTasks2","XHR_TASK","sendNative","placeholderCallback","abortNative","openNative","XHR_SYNC","XHR_URL","fetchTaskAborting","fetchTaskScheduling","url","findPendingTask","navigator","geolocation","patchPrototype","fnNames","delegate2","findPromiseRejectionHandler","PromiseRejectionEvent","evt","patchQueueMicrotask"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./node_modules/zone.js/fesm2015/zone.js"],"sourcesContent":["'use strict';\n/**\n * @license Angular\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n// packages/zone.js/lib/zone-impl.js\nvar global = globalThis;\nfunction __symbol__(name) {\n  const symbolPrefix = global[\"__Zone_symbol_prefix\"] || \"__zone_symbol__\";\n  return symbolPrefix + name;\n}\nfunction initZone() {\n  const performance = global[\"performance\"];\n  function mark(name) {\n    performance && performance[\"mark\"] && performance[\"mark\"](name);\n  }\n  function performanceMeasure(name, label) {\n    performance && performance[\"measure\"] && performance[\"measure\"](name, label);\n  }\n  mark(\"Zone\");\n  const _ZoneImpl = class _ZoneImpl {\n    constructor(parent, zoneSpec) {\n      __publicField(this, \"_parent\");\n      __publicField(this, \"_name\");\n      __publicField(this, \"_properties\");\n      __publicField(this, \"_zoneDelegate\");\n      this._parent = parent;\n      this._name = zoneSpec ? zoneSpec.name || \"unnamed\" : \"<root>\";\n      this._properties = zoneSpec && zoneSpec.properties || {};\n      this._zoneDelegate = new _ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);\n    }\n    static assertZonePatched() {\n      if (global[\"Promise\"] !== patches[\"ZoneAwarePromise\"]) {\n        throw new Error(\"Zone.js has detected that ZoneAwarePromise `(window|global).Promise` has been overwritten.\\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)\");\n      }\n    }\n    static get root() {\n      let zone = _ZoneImpl.current;\n      while (zone.parent) {\n        zone = zone.parent;\n      }\n      return zone;\n    }\n    static get current() {\n      return _currentZoneFrame.zone;\n    }\n    static get currentTask() {\n      return _currentTask;\n    }\n    static __load_patch(name, fn, ignoreDuplicate = false) {\n      if (patches.hasOwnProperty(name)) {\n        const checkDuplicate = global[__symbol__(\"forceDuplicateZoneCheck\")] === true;\n        if (!ignoreDuplicate && checkDuplicate) {\n          throw Error(\"Already loaded patch: \" + name);\n        }\n      } else if (!global[\"__Zone_disable_\" + name]) {\n        const perfName = \"Zone:\" + name;\n        mark(perfName);\n        patches[name] = fn(global, _ZoneImpl, _api);\n        performanceMeasure(perfName, perfName);\n      }\n    }\n    get parent() {\n      return this._parent;\n    }\n    get name() {\n      return this._name;\n    }\n    get(key) {\n      const zone = this.getZoneWith(key);\n      if (zone)\n        return zone._properties[key];\n    }\n    getZoneWith(key) {\n      let current = this;\n      while (current) {\n        if (current._properties.hasOwnProperty(key)) {\n          return current;\n        }\n        current = current._parent;\n      }\n      return null;\n    }\n    fork(zoneSpec) {\n      if (!zoneSpec)\n        throw new Error(\"ZoneSpec required!\");\n      return this._zoneDelegate.fork(this, zoneSpec);\n    }\n    wrap(callback, source) {\n      if (typeof callback !== \"function\") {\n        throw new Error(\"Expecting function got: \" + callback);\n      }\n      const _callback = this._zoneDelegate.intercept(this, callback, source);\n      const zone = this;\n      return function() {\n        return zone.runGuarded(_callback, this, arguments, source);\n      };\n    }\n    run(callback, applyThis, applyArgs, source) {\n      _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\n      try {\n        return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n      } finally {\n        _currentZoneFrame = _currentZoneFrame.parent;\n      }\n    }\n    runGuarded(callback, applyThis = null, applyArgs, source) {\n      _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\n      try {\n        try {\n          return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n        } catch (error) {\n          if (this._zoneDelegate.handleError(this, error)) {\n            throw error;\n          }\n        }\n      } finally {\n        _currentZoneFrame = _currentZoneFrame.parent;\n      }\n    }\n    runTask(task, applyThis, applyArgs) {\n      if (task.zone != this) {\n        throw new Error(\"A task can only be run in the zone of creation! (Creation: \" + (task.zone || NO_ZONE).name + \"; Execution: \" + this.name + \")\");\n      }\n      const zoneTask = task;\n      const { type, data: { isPeriodic = false, isRefreshable = false } = {} } = task;\n      if (task.state === notScheduled && (type === eventTask || type === macroTask)) {\n        return;\n      }\n      const reEntryGuard = task.state != running;\n      reEntryGuard && zoneTask._transitionTo(running, scheduled);\n      const previousTask = _currentTask;\n      _currentTask = zoneTask;\n      _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\n      try {\n        if (type == macroTask && task.data && !isPeriodic && !isRefreshable) {\n          task.cancelFn = void 0;\n        }\n        try {\n          return this._zoneDelegate.invokeTask(this, zoneTask, applyThis, applyArgs);\n        } catch (error) {\n          if (this._zoneDelegate.handleError(this, error)) {\n            throw error;\n          }\n        }\n      } finally {\n        const state = task.state;\n        if (state !== notScheduled && state !== unknown) {\n          if (type == eventTask || isPeriodic || isRefreshable && state === scheduling) {\n            reEntryGuard && zoneTask._transitionTo(scheduled, running, scheduling);\n          } else {\n            const zoneDelegates = zoneTask._zoneDelegates;\n            this._updateTaskCount(zoneTask, -1);\n            reEntryGuard && zoneTask._transitionTo(notScheduled, running, notScheduled);\n            if (isRefreshable) {\n              zoneTask._zoneDelegates = zoneDelegates;\n            }\n          }\n        }\n        _currentZoneFrame = _currentZoneFrame.parent;\n        _currentTask = previousTask;\n      }\n    }\n    scheduleTask(task) {\n      if (task.zone && task.zone !== this) {\n        let newZone = this;\n        while (newZone) {\n          if (newZone === task.zone) {\n            throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${task.zone.name}`);\n          }\n          newZone = newZone.parent;\n        }\n      }\n      task._transitionTo(scheduling, notScheduled);\n      const zoneDelegates = [];\n      task._zoneDelegates = zoneDelegates;\n      task._zone = this;\n      try {\n        task = this._zoneDelegate.scheduleTask(this, task);\n      } catch (err) {\n        task._transitionTo(unknown, scheduling, notScheduled);\n        this._zoneDelegate.handleError(this, err);\n        throw err;\n      }\n      if (task._zoneDelegates === zoneDelegates) {\n        this._updateTaskCount(task, 1);\n      }\n      if (task.state == scheduling) {\n        task._transitionTo(scheduled, scheduling);\n      }\n      return task;\n    }\n    scheduleMicroTask(source, callback, data, customSchedule) {\n      return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, void 0));\n    }\n    scheduleMacroTask(source, callback, data, customSchedule, customCancel) {\n      return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));\n    }\n    scheduleEventTask(source, callback, data, customSchedule, customCancel) {\n      return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));\n    }\n    cancelTask(task) {\n      if (task.zone != this)\n        throw new Error(\"A task can only be cancelled in the zone of creation! (Creation: \" + (task.zone || NO_ZONE).name + \"; Execution: \" + this.name + \")\");\n      if (task.state !== scheduled && task.state !== running) {\n        return;\n      }\n      task._transitionTo(canceling, scheduled, running);\n      try {\n        this._zoneDelegate.cancelTask(this, task);\n      } catch (err) {\n        task._transitionTo(unknown, canceling);\n        this._zoneDelegate.handleError(this, err);\n        throw err;\n      }\n      this._updateTaskCount(task, -1);\n      task._transitionTo(notScheduled, canceling);\n      task.runCount = -1;\n      return task;\n    }\n    _updateTaskCount(task, count) {\n      const zoneDelegates = task._zoneDelegates;\n      if (count == -1) {\n        task._zoneDelegates = null;\n      }\n      for (let i = 0; i < zoneDelegates.length; i++) {\n        zoneDelegates[i]._updateTaskCount(task.type, count);\n      }\n    }\n  };\n  __publicField(_ZoneImpl, \"__symbol__\", __symbol__);\n  let ZoneImpl = _ZoneImpl;\n  const DELEGATE_ZS = {\n    name: \"\",\n    onHasTask: (delegate, _, target, hasTaskState) => delegate.hasTask(target, hasTaskState),\n    onScheduleTask: (delegate, _, target, task) => delegate.scheduleTask(target, task),\n    onInvokeTask: (delegate, _, target, task, applyThis, applyArgs) => delegate.invokeTask(target, task, applyThis, applyArgs),\n    onCancelTask: (delegate, _, target, task) => delegate.cancelTask(target, task)\n  };\n  class _ZoneDelegate {\n    constructor(zone, parentDelegate, zoneSpec) {\n      __publicField(this, \"_zone\");\n      __publicField(this, \"_taskCounts\", {\n        \"microTask\": 0,\n        \"macroTask\": 0,\n        \"eventTask\": 0\n      });\n      __publicField(this, \"_parentDelegate\");\n      __publicField(this, \"_forkDlgt\");\n      __publicField(this, \"_forkZS\");\n      __publicField(this, \"_forkCurrZone\");\n      __publicField(this, \"_interceptDlgt\");\n      __publicField(this, \"_interceptZS\");\n      __publicField(this, \"_interceptCurrZone\");\n      __publicField(this, \"_invokeDlgt\");\n      __publicField(this, \"_invokeZS\");\n      __publicField(this, \"_invokeCurrZone\");\n      __publicField(this, \"_handleErrorDlgt\");\n      __publicField(this, \"_handleErrorZS\");\n      __publicField(this, \"_handleErrorCurrZone\");\n      __publicField(this, \"_scheduleTaskDlgt\");\n      __publicField(this, \"_scheduleTaskZS\");\n      __publicField(this, \"_scheduleTaskCurrZone\");\n      __publicField(this, \"_invokeTaskDlgt\");\n      __publicField(this, \"_invokeTaskZS\");\n      __publicField(this, \"_invokeTaskCurrZone\");\n      __publicField(this, \"_cancelTaskDlgt\");\n      __publicField(this, \"_cancelTaskZS\");\n      __publicField(this, \"_cancelTaskCurrZone\");\n      __publicField(this, \"_hasTaskDlgt\");\n      __publicField(this, \"_hasTaskDlgtOwner\");\n      __publicField(this, \"_hasTaskZS\");\n      __publicField(this, \"_hasTaskCurrZone\");\n      this._zone = zone;\n      this._parentDelegate = parentDelegate;\n      this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);\n      this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);\n      this._forkCurrZone = zoneSpec && (zoneSpec.onFork ? this._zone : parentDelegate._forkCurrZone);\n      this._interceptZS = zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);\n      this._interceptDlgt = zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);\n      this._interceptCurrZone = zoneSpec && (zoneSpec.onIntercept ? this._zone : parentDelegate._interceptCurrZone);\n      this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);\n      this._invokeDlgt = zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);\n      this._invokeCurrZone = zoneSpec && (zoneSpec.onInvoke ? this._zone : parentDelegate._invokeCurrZone);\n      this._handleErrorZS = zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);\n      this._handleErrorDlgt = zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);\n      this._handleErrorCurrZone = zoneSpec && (zoneSpec.onHandleError ? this._zone : parentDelegate._handleErrorCurrZone);\n      this._scheduleTaskZS = zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);\n      this._scheduleTaskDlgt = zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);\n      this._scheduleTaskCurrZone = zoneSpec && (zoneSpec.onScheduleTask ? this._zone : parentDelegate._scheduleTaskCurrZone);\n      this._invokeTaskZS = zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);\n      this._invokeTaskDlgt = zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);\n      this._invokeTaskCurrZone = zoneSpec && (zoneSpec.onInvokeTask ? this._zone : parentDelegate._invokeTaskCurrZone);\n      this._cancelTaskZS = zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);\n      this._cancelTaskDlgt = zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);\n      this._cancelTaskCurrZone = zoneSpec && (zoneSpec.onCancelTask ? this._zone : parentDelegate._cancelTaskCurrZone);\n      this._hasTaskZS = null;\n      this._hasTaskDlgt = null;\n      this._hasTaskDlgtOwner = null;\n      this._hasTaskCurrZone = null;\n      const zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;\n      const parentHasTask = parentDelegate && parentDelegate._hasTaskZS;\n      if (zoneSpecHasTask || parentHasTask) {\n        this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;\n        this._hasTaskDlgt = parentDelegate;\n        this._hasTaskDlgtOwner = this;\n        this._hasTaskCurrZone = this._zone;\n        if (!zoneSpec.onScheduleTask) {\n          this._scheduleTaskZS = DELEGATE_ZS;\n          this._scheduleTaskDlgt = parentDelegate;\n          this._scheduleTaskCurrZone = this._zone;\n        }\n        if (!zoneSpec.onInvokeTask) {\n          this._invokeTaskZS = DELEGATE_ZS;\n          this._invokeTaskDlgt = parentDelegate;\n          this._invokeTaskCurrZone = this._zone;\n        }\n        if (!zoneSpec.onCancelTask) {\n          this._cancelTaskZS = DELEGATE_ZS;\n          this._cancelTaskDlgt = parentDelegate;\n          this._cancelTaskCurrZone = this._zone;\n        }\n      }\n    }\n    get zone() {\n      return this._zone;\n    }\n    fork(targetZone, zoneSpec) {\n      return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) : new ZoneImpl(targetZone, zoneSpec);\n    }\n    intercept(targetZone, callback, source) {\n      return this._interceptZS ? this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) : callback;\n    }\n    invoke(targetZone, callback, applyThis, applyArgs, source) {\n      return this._invokeZS ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) : callback.apply(applyThis, applyArgs);\n    }\n    handleError(targetZone, error) {\n      return this._handleErrorZS ? this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error) : true;\n    }\n    scheduleTask(targetZone, task) {\n      let returnTask = task;\n      if (this._scheduleTaskZS) {\n        if (this._hasTaskZS) {\n          returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);\n        }\n        returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);\n        if (!returnTask)\n          returnTask = task;\n      } else {\n        if (task.scheduleFn) {\n          task.scheduleFn(task);\n        } else if (task.type == microTask) {\n          scheduleMicroTask(task);\n        } else {\n          throw new Error(\"Task is missing scheduleFn.\");\n        }\n      }\n      return returnTask;\n    }\n    invokeTask(targetZone, task, applyThis, applyArgs) {\n      return this._invokeTaskZS ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) : task.callback.apply(applyThis, applyArgs);\n    }\n    cancelTask(targetZone, task) {\n      let value;\n      if (this._cancelTaskZS) {\n        value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);\n      } else {\n        if (!task.cancelFn) {\n          throw Error(\"Task is not cancelable\");\n        }\n        value = task.cancelFn(task);\n      }\n      return value;\n    }\n    hasTask(targetZone, isEmpty) {\n      try {\n        this._hasTaskZS && this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);\n      } catch (err) {\n        this.handleError(targetZone, err);\n      }\n    }\n    _updateTaskCount(type, count) {\n      const counts = this._taskCounts;\n      const prev = counts[type];\n      const next = counts[type] = prev + count;\n      if (next < 0) {\n        throw new Error(\"More tasks executed then were scheduled.\");\n      }\n      if (prev == 0 || next == 0) {\n        const isEmpty = {\n          microTask: counts[\"microTask\"] > 0,\n          macroTask: counts[\"macroTask\"] > 0,\n          eventTask: counts[\"eventTask\"] > 0,\n          change: type\n        };\n        this.hasTask(this._zone, isEmpty);\n      }\n    }\n  }\n  class ZoneTask {\n    constructor(type, source, callback, options, scheduleFn, cancelFn) {\n      __publicField(this, \"type\");\n      __publicField(this, \"source\");\n      __publicField(this, \"invoke\");\n      __publicField(this, \"callback\");\n      __publicField(this, \"data\");\n      __publicField(this, \"scheduleFn\");\n      __publicField(this, \"cancelFn\");\n      __publicField(this, \"_zone\", null);\n      __publicField(this, \"runCount\", 0);\n      __publicField(this, \"_zoneDelegates\", null);\n      __publicField(this, \"_state\", \"notScheduled\");\n      this.type = type;\n      this.source = source;\n      this.data = options;\n      this.scheduleFn = scheduleFn;\n      this.cancelFn = cancelFn;\n      if (!callback) {\n        throw new Error(\"callback is not defined\");\n      }\n      this.callback = callback;\n      const self2 = this;\n      if (type === eventTask && options && options.useG) {\n        this.invoke = ZoneTask.invokeTask;\n      } else {\n        this.invoke = function() {\n          return ZoneTask.invokeTask.call(global, self2, this, arguments);\n        };\n      }\n    }\n    static invokeTask(task, target, args) {\n      if (!task) {\n        task = this;\n      }\n      _numberOfNestedTaskFrames++;\n      try {\n        task.runCount++;\n        return task.zone.runTask(task, target, args);\n      } finally {\n        if (_numberOfNestedTaskFrames == 1) {\n          drainMicroTaskQueue();\n        }\n        _numberOfNestedTaskFrames--;\n      }\n    }\n    get zone() {\n      return this._zone;\n    }\n    get state() {\n      return this._state;\n    }\n    cancelScheduleRequest() {\n      this._transitionTo(notScheduled, scheduling);\n    }\n    _transitionTo(toState, fromState1, fromState2) {\n      if (this._state === fromState1 || this._state === fromState2) {\n        this._state = toState;\n        if (toState == notScheduled) {\n          this._zoneDelegates = null;\n        }\n      } else {\n        throw new Error(`${this.type} '${this.source}': can not transition to '${toState}', expecting state '${fromState1}'${fromState2 ? \" or '\" + fromState2 + \"'\" : \"\"}, was '${this._state}'.`);\n      }\n    }\n    toString() {\n      if (this.data && typeof this.data.handleId !== \"undefined\") {\n        return this.data.handleId.toString();\n      } else {\n        return Object.prototype.toString.call(this);\n      }\n    }\n    // add toJSON method to prevent cyclic error when\n    // call JSON.stringify(zoneTask)\n    toJSON() {\n      return {\n        type: this.type,\n        state: this.state,\n        source: this.source,\n        zone: this.zone.name,\n        runCount: this.runCount\n      };\n    }\n  }\n  const symbolSetTimeout = __symbol__(\"setTimeout\");\n  const symbolPromise = __symbol__(\"Promise\");\n  const symbolThen = __symbol__(\"then\");\n  let _microTaskQueue = [];\n  let _isDrainingMicrotaskQueue = false;\n  let nativeMicroTaskQueuePromise;\n  function nativeScheduleMicroTask(func) {\n    if (!nativeMicroTaskQueuePromise) {\n      if (global[symbolPromise]) {\n        nativeMicroTaskQueuePromise = global[symbolPromise].resolve(0);\n      }\n    }\n    if (nativeMicroTaskQueuePromise) {\n      let nativeThen = nativeMicroTaskQueuePromise[symbolThen];\n      if (!nativeThen) {\n        nativeThen = nativeMicroTaskQueuePromise[\"then\"];\n      }\n      nativeThen.call(nativeMicroTaskQueuePromise, func);\n    } else {\n      global[symbolSetTimeout](func, 0);\n    }\n  }\n  function scheduleMicroTask(task) {\n    if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {\n      nativeScheduleMicroTask(drainMicroTaskQueue);\n    }\n    task && _microTaskQueue.push(task);\n  }\n  function drainMicroTaskQueue() {\n    if (!_isDrainingMicrotaskQueue) {\n      _isDrainingMicrotaskQueue = true;\n      while (_microTaskQueue.length) {\n        const queue = _microTaskQueue;\n        _microTaskQueue = [];\n        for (let i = 0; i < queue.length; i++) {\n          const task = queue[i];\n          try {\n            task.zone.runTask(task, null, null);\n          } catch (error) {\n            _api.onUnhandledError(error);\n          }\n        }\n      }\n      _api.microtaskDrainDone();\n      _isDrainingMicrotaskQueue = false;\n    }\n  }\n  const NO_ZONE = { name: \"NO ZONE\" };\n  const notScheduled = \"notScheduled\", scheduling = \"scheduling\", scheduled = \"scheduled\", running = \"running\", canceling = \"canceling\", unknown = \"unknown\";\n  const microTask = \"microTask\", macroTask = \"macroTask\", eventTask = \"eventTask\";\n  const patches = {};\n  const _api = {\n    symbol: __symbol__,\n    currentZoneFrame: () => _currentZoneFrame,\n    onUnhandledError: noop,\n    microtaskDrainDone: noop,\n    scheduleMicroTask,\n    showUncaughtError: () => !ZoneImpl[__symbol__(\"ignoreConsoleErrorUncaughtError\")],\n    patchEventTarget: () => [],\n    patchOnProperties: noop,\n    patchMethod: () => noop,\n    bindArguments: () => [],\n    patchThen: () => noop,\n    patchMacroTask: () => noop,\n    patchEventPrototype: () => noop,\n    getGlobalObjects: () => void 0,\n    ObjectDefineProperty: () => noop,\n    ObjectGetOwnPropertyDescriptor: () => void 0,\n    ObjectCreate: () => void 0,\n    ArraySlice: () => [],\n    patchClass: () => noop,\n    wrapWithCurrentZone: () => noop,\n    filterProperties: () => [],\n    attachOriginToPatched: () => noop,\n    _redefineProperty: () => noop,\n    patchCallbacks: () => noop,\n    nativeScheduleMicroTask\n  };\n  let _currentZoneFrame = { parent: null, zone: new ZoneImpl(null, null) };\n  let _currentTask = null;\n  let _numberOfNestedTaskFrames = 0;\n  function noop() {\n  }\n  performanceMeasure(\"Zone\", \"Zone\");\n  return ZoneImpl;\n}\n\n// packages/zone.js/lib/zone.js\nfunction loadZone() {\n  var _a;\n  const global2 = globalThis;\n  const checkDuplicate = global2[__symbol__(\"forceDuplicateZoneCheck\")] === true;\n  if (global2[\"Zone\"] && (checkDuplicate || typeof global2[\"Zone\"].__symbol__ !== \"function\")) {\n    throw new Error(\"Zone already loaded.\");\n  }\n  (_a = global2[\"Zone\"]) != null ? _a : global2[\"Zone\"] = initZone();\n  return global2[\"Zone\"];\n}\n\n// packages/zone.js/lib/common/utils.js\nvar ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ObjectDefineProperty = Object.defineProperty;\nvar ObjectGetPrototypeOf = Object.getPrototypeOf;\nvar ObjectCreate = Object.create;\nvar ArraySlice = Array.prototype.slice;\nvar ADD_EVENT_LISTENER_STR = \"addEventListener\";\nvar REMOVE_EVENT_LISTENER_STR = \"removeEventListener\";\nvar ZONE_SYMBOL_ADD_EVENT_LISTENER = __symbol__(ADD_EVENT_LISTENER_STR);\nvar ZONE_SYMBOL_REMOVE_EVENT_LISTENER = __symbol__(REMOVE_EVENT_LISTENER_STR);\nvar TRUE_STR = \"true\";\nvar FALSE_STR = \"false\";\nvar ZONE_SYMBOL_PREFIX = __symbol__(\"\");\nfunction wrapWithCurrentZone(callback, source) {\n  return Zone.current.wrap(callback, source);\n}\nfunction scheduleMacroTaskWithCurrentZone(source, callback, data, customSchedule, customCancel) {\n  return Zone.current.scheduleMacroTask(source, callback, data, customSchedule, customCancel);\n}\nvar zoneSymbol = __symbol__;\nvar isWindowExists = typeof window !== \"undefined\";\nvar internalWindow = isWindowExists ? window : void 0;\nvar _global = isWindowExists && internalWindow || globalThis;\nvar REMOVE_ATTRIBUTE = \"removeAttribute\";\nfunction bindArguments(args, source) {\n  for (let i = args.length - 1; i >= 0; i--) {\n    if (typeof args[i] === \"function\") {\n      args[i] = wrapWithCurrentZone(args[i], source + \"_\" + i);\n    }\n  }\n  return args;\n}\nfunction patchPrototype(prototype, fnNames) {\n  const source = prototype.constructor[\"name\"];\n  for (let i = 0; i < fnNames.length; i++) {\n    const name = fnNames[i];\n    const delegate = prototype[name];\n    if (delegate) {\n      const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, name);\n      if (!isPropertyWritable(prototypeDesc)) {\n        continue;\n      }\n      prototype[name] = ((delegate2) => {\n        const patched = function() {\n          return delegate2.apply(this, bindArguments(arguments, source + \".\" + name));\n        };\n        attachOriginToPatched(patched, delegate2);\n        return patched;\n      })(delegate);\n    }\n  }\n}\nfunction isPropertyWritable(propertyDesc) {\n  if (!propertyDesc) {\n    return true;\n  }\n  if (propertyDesc.writable === false) {\n    return false;\n  }\n  return !(typeof propertyDesc.get === \"function\" && typeof propertyDesc.set === \"undefined\");\n}\nvar isWebWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\nvar isNode = !(\"nw\" in _global) && typeof _global.process !== \"undefined\" && _global.process.toString() === \"[object process]\";\nvar isBrowser = !isNode && !isWebWorker && !!(isWindowExists && internalWindow[\"HTMLElement\"]);\nvar isMix = typeof _global.process !== \"undefined\" && _global.process.toString() === \"[object process]\" && !isWebWorker && !!(isWindowExists && internalWindow[\"HTMLElement\"]);\nvar zoneSymbolEventNames = {};\nvar enableBeforeunloadSymbol = zoneSymbol(\"enable_beforeunload\");\nvar wrapFn = function(event) {\n  event = event || _global.event;\n  if (!event) {\n    return;\n  }\n  let eventNameSymbol = zoneSymbolEventNames[event.type];\n  if (!eventNameSymbol) {\n    eventNameSymbol = zoneSymbolEventNames[event.type] = zoneSymbol(\"ON_PROPERTY\" + event.type);\n  }\n  const target = this || event.target || _global;\n  const listener = target[eventNameSymbol];\n  let result;\n  if (isBrowser && target === internalWindow && event.type === \"error\") {\n    const errorEvent = event;\n    result = listener && listener.call(this, errorEvent.message, errorEvent.filename, errorEvent.lineno, errorEvent.colno, errorEvent.error);\n    if (result === true) {\n      event.preventDefault();\n    }\n  } else {\n    result = listener && listener.apply(this, arguments);\n    if (\n      // https://github.com/angular/angular/issues/47579\n      // https://www.w3.org/TR/2011/WD-html5-20110525/history.html#beforeunloadevent\n      // This is the only specific case we should check for. The spec defines that the\n      // `returnValue` attribute represents the message to show the user. When the event\n      // is created, this attribute must be set to the empty string.\n      event.type === \"beforeunload\" && // To prevent any breaking changes resulting from this change, given that\n      // it was already causing a significant number of failures in G3, we have hidden\n      // that behavior behind a global configuration flag. Consumers can enable this\n      // flag explicitly if they want the `beforeunload` event to be handled as defined\n      // in the specification.\n      _global[enableBeforeunloadSymbol] && // The IDL event definition is `attribute DOMString returnValue`, so we check whether\n      // `typeof result` is a string.\n      typeof result === \"string\"\n    ) {\n      event.returnValue = result;\n    } else if (result != void 0 && !result) {\n      event.preventDefault();\n    }\n  }\n  return result;\n};\nfunction patchProperty(obj, prop, prototype) {\n  let desc = ObjectGetOwnPropertyDescriptor(obj, prop);\n  if (!desc && prototype) {\n    const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, prop);\n    if (prototypeDesc) {\n      desc = { enumerable: true, configurable: true };\n    }\n  }\n  if (!desc || !desc.configurable) {\n    return;\n  }\n  const onPropPatchedSymbol = zoneSymbol(\"on\" + prop + \"patched\");\n  if (obj.hasOwnProperty(onPropPatchedSymbol) && obj[onPropPatchedSymbol]) {\n    return;\n  }\n  delete desc.writable;\n  delete desc.value;\n  const originalDescGet = desc.get;\n  const originalDescSet = desc.set;\n  const eventName = prop.slice(2);\n  let eventNameSymbol = zoneSymbolEventNames[eventName];\n  if (!eventNameSymbol) {\n    eventNameSymbol = zoneSymbolEventNames[eventName] = zoneSymbol(\"ON_PROPERTY\" + eventName);\n  }\n  desc.set = function(newValue) {\n    let target = this;\n    if (!target && obj === _global) {\n      target = _global;\n    }\n    if (!target) {\n      return;\n    }\n    const previousValue = target[eventNameSymbol];\n    if (typeof previousValue === \"function\") {\n      target.removeEventListener(eventName, wrapFn);\n    }\n    originalDescSet == null ? void 0 : originalDescSet.call(target, null);\n    target[eventNameSymbol] = newValue;\n    if (typeof newValue === \"function\") {\n      target.addEventListener(eventName, wrapFn, false);\n    }\n  };\n  desc.get = function() {\n    let target = this;\n    if (!target && obj === _global) {\n      target = _global;\n    }\n    if (!target) {\n      return null;\n    }\n    const listener = target[eventNameSymbol];\n    if (listener) {\n      return listener;\n    } else if (originalDescGet) {\n      let value = originalDescGet.call(this);\n      if (value) {\n        desc.set.call(this, value);\n        if (typeof target[REMOVE_ATTRIBUTE] === \"function\") {\n          target.removeAttribute(prop);\n        }\n        return value;\n      }\n    }\n    return null;\n  };\n  ObjectDefineProperty(obj, prop, desc);\n  obj[onPropPatchedSymbol] = true;\n}\nfunction patchOnProperties(obj, properties, prototype) {\n  if (properties) {\n    for (let i = 0; i < properties.length; i++) {\n      patchProperty(obj, \"on\" + properties[i], prototype);\n    }\n  } else {\n    const onProperties = [];\n    for (const prop in obj) {\n      if (prop.slice(0, 2) == \"on\") {\n        onProperties.push(prop);\n      }\n    }\n    for (let j = 0; j < onProperties.length; j++) {\n      patchProperty(obj, onProperties[j], prototype);\n    }\n  }\n}\nvar originalInstanceKey = zoneSymbol(\"originalInstance\");\nfunction patchClass(className) {\n  const OriginalClass = _global[className];\n  if (!OriginalClass)\n    return;\n  _global[zoneSymbol(className)] = OriginalClass;\n  _global[className] = function() {\n    const a = bindArguments(arguments, className);\n    switch (a.length) {\n      case 0:\n        this[originalInstanceKey] = new OriginalClass();\n        break;\n      case 1:\n        this[originalInstanceKey] = new OriginalClass(a[0]);\n        break;\n      case 2:\n        this[originalInstanceKey] = new OriginalClass(a[0], a[1]);\n        break;\n      case 3:\n        this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);\n        break;\n      case 4:\n        this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);\n        break;\n      default:\n        throw new Error(\"Arg list too long.\");\n    }\n  };\n  attachOriginToPatched(_global[className], OriginalClass);\n  const instance = new OriginalClass(function() {\n  });\n  let prop;\n  for (prop in instance) {\n    if (className === \"XMLHttpRequest\" && prop === \"responseBlob\")\n      continue;\n    (function(prop2) {\n      if (typeof instance[prop2] === \"function\") {\n        _global[className].prototype[prop2] = function() {\n          return this[originalInstanceKey][prop2].apply(this[originalInstanceKey], arguments);\n        };\n      } else {\n        ObjectDefineProperty(_global[className].prototype, prop2, {\n          set: function(fn) {\n            if (typeof fn === \"function\") {\n              this[originalInstanceKey][prop2] = wrapWithCurrentZone(fn, className + \".\" + prop2);\n              attachOriginToPatched(this[originalInstanceKey][prop2], fn);\n            } else {\n              this[originalInstanceKey][prop2] = fn;\n            }\n          },\n          get: function() {\n            return this[originalInstanceKey][prop2];\n          }\n        });\n      }\n    })(prop);\n  }\n  for (prop in OriginalClass) {\n    if (prop !== \"prototype\" && OriginalClass.hasOwnProperty(prop)) {\n      _global[className][prop] = OriginalClass[prop];\n    }\n  }\n}\nfunction copySymbolProperties(src, dest) {\n  if (typeof Object.getOwnPropertySymbols !== \"function\") {\n    return;\n  }\n  const symbols = Object.getOwnPropertySymbols(src);\n  symbols.forEach((symbol) => {\n    const desc = Object.getOwnPropertyDescriptor(src, symbol);\n    Object.defineProperty(dest, symbol, {\n      get: function() {\n        return src[symbol];\n      },\n      set: function(value) {\n        if (desc && (!desc.writable || typeof desc.set !== \"function\")) {\n          return;\n        }\n        src[symbol] = value;\n      },\n      enumerable: desc ? desc.enumerable : true,\n      configurable: desc ? desc.configurable : true\n    });\n  });\n}\nvar shouldCopySymbolProperties = false;\nfunction patchMethod(target, name, patchFn) {\n  let proto = target;\n  while (proto && !proto.hasOwnProperty(name)) {\n    proto = ObjectGetPrototypeOf(proto);\n  }\n  if (!proto && target[name]) {\n    proto = target;\n  }\n  const delegateName = zoneSymbol(name);\n  let delegate = null;\n  if (proto && (!(delegate = proto[delegateName]) || !proto.hasOwnProperty(delegateName))) {\n    delegate = proto[delegateName] = proto[name];\n    const desc = proto && ObjectGetOwnPropertyDescriptor(proto, name);\n    if (isPropertyWritable(desc)) {\n      const patchDelegate = patchFn(delegate, delegateName, name);\n      proto[name] = function() {\n        return patchDelegate(this, arguments);\n      };\n      attachOriginToPatched(proto[name], delegate);\n      if (shouldCopySymbolProperties) {\n        copySymbolProperties(delegate, proto[name]);\n      }\n    }\n  }\n  return delegate;\n}\nfunction patchMacroTask(obj, funcName, metaCreator) {\n  let setNative = null;\n  function scheduleTask(task) {\n    const data = task.data;\n    data.args[data.cbIdx] = function() {\n      task.invoke.apply(this, arguments);\n    };\n    setNative.apply(data.target, data.args);\n    return task;\n  }\n  setNative = patchMethod(obj, funcName, (delegate) => function(self2, args) {\n    const meta = metaCreator(self2, args);\n    if (meta.cbIdx >= 0 && typeof args[meta.cbIdx] === \"function\") {\n      return scheduleMacroTaskWithCurrentZone(meta.name, args[meta.cbIdx], meta, scheduleTask);\n    } else {\n      return delegate.apply(self2, args);\n    }\n  });\n}\nfunction attachOriginToPatched(patched, original) {\n  patched[zoneSymbol(\"OriginalDelegate\")] = original;\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction isNumber(value) {\n  return typeof value === \"number\";\n}\n\n// packages/zone.js/lib/common/events.js\nvar OPTIMIZED_ZONE_EVENT_TASK_DATA = {\n  useG: true\n};\nvar zoneSymbolEventNames2 = {};\nvar globalSources = {};\nvar EVENT_NAME_SYMBOL_REGX = new RegExp(\"^\" + ZONE_SYMBOL_PREFIX + \"(\\\\w+)(true|false)$\");\nvar IMMEDIATE_PROPAGATION_SYMBOL = zoneSymbol(\"propagationStopped\");\nfunction prepareEventNames(eventName, eventNameToString) {\n  const falseEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + FALSE_STR;\n  const trueEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + TRUE_STR;\n  const symbol = ZONE_SYMBOL_PREFIX + falseEventName;\n  const symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;\n  zoneSymbolEventNames2[eventName] = {};\n  zoneSymbolEventNames2[eventName][FALSE_STR] = symbol;\n  zoneSymbolEventNames2[eventName][TRUE_STR] = symbolCapture;\n}\nfunction patchEventTarget(_global2, api, apis, patchOptions) {\n  const ADD_EVENT_LISTENER = patchOptions && patchOptions.add || ADD_EVENT_LISTENER_STR;\n  const REMOVE_EVENT_LISTENER = patchOptions && patchOptions.rm || REMOVE_EVENT_LISTENER_STR;\n  const LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.listeners || \"eventListeners\";\n  const REMOVE_ALL_LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.rmAll || \"removeAllListeners\";\n  const zoneSymbolAddEventListener = zoneSymbol(ADD_EVENT_LISTENER);\n  const ADD_EVENT_LISTENER_SOURCE = \".\" + ADD_EVENT_LISTENER + \":\";\n  const PREPEND_EVENT_LISTENER = \"prependListener\";\n  const PREPEND_EVENT_LISTENER_SOURCE = \".\" + PREPEND_EVENT_LISTENER + \":\";\n  const invokeTask = function(task, target, event) {\n    if (task.isRemoved) {\n      return;\n    }\n    const delegate = task.callback;\n    if (typeof delegate === \"object\" && delegate.handleEvent) {\n      task.callback = (event2) => delegate.handleEvent(event2);\n      task.originalDelegate = delegate;\n    }\n    let error;\n    try {\n      task.invoke(task, target, [event]);\n    } catch (err) {\n      error = err;\n    }\n    const options = task.options;\n    if (options && typeof options === \"object\" && options.once) {\n      const delegate2 = task.originalDelegate ? task.originalDelegate : task.callback;\n      target[REMOVE_EVENT_LISTENER].call(target, event.type, delegate2, options);\n    }\n    return error;\n  };\n  function globalCallback(context, event, isCapture) {\n    event = event || _global2.event;\n    if (!event) {\n      return;\n    }\n    const target = context || event.target || _global2;\n    const tasks = target[zoneSymbolEventNames2[event.type][isCapture ? TRUE_STR : FALSE_STR]];\n    if (tasks) {\n      const errors = [];\n      if (tasks.length === 1) {\n        const err = invokeTask(tasks[0], target, event);\n        err && errors.push(err);\n      } else {\n        const copyTasks = tasks.slice();\n        for (let i = 0; i < copyTasks.length; i++) {\n          if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {\n            break;\n          }\n          const err = invokeTask(copyTasks[i], target, event);\n          err && errors.push(err);\n        }\n      }\n      if (errors.length === 1) {\n        throw errors[0];\n      } else {\n        for (let i = 0; i < errors.length; i++) {\n          const err = errors[i];\n          api.nativeScheduleMicroTask(() => {\n            throw err;\n          });\n        }\n      }\n    }\n  }\n  const globalZoneAwareCallback = function(event) {\n    return globalCallback(this, event, false);\n  };\n  const globalZoneAwareCaptureCallback = function(event) {\n    return globalCallback(this, event, true);\n  };\n  function patchEventTargetMethods(obj, patchOptions2) {\n    if (!obj) {\n      return false;\n    }\n    let useGlobalCallback = true;\n    if (patchOptions2 && patchOptions2.useG !== void 0) {\n      useGlobalCallback = patchOptions2.useG;\n    }\n    const validateHandler = patchOptions2 && patchOptions2.vh;\n    let checkDuplicate = true;\n    if (patchOptions2 && patchOptions2.chkDup !== void 0) {\n      checkDuplicate = patchOptions2.chkDup;\n    }\n    let returnTarget = false;\n    if (patchOptions2 && patchOptions2.rt !== void 0) {\n      returnTarget = patchOptions2.rt;\n    }\n    let proto = obj;\n    while (proto && !proto.hasOwnProperty(ADD_EVENT_LISTENER)) {\n      proto = ObjectGetPrototypeOf(proto);\n    }\n    if (!proto && obj[ADD_EVENT_LISTENER]) {\n      proto = obj;\n    }\n    if (!proto) {\n      return false;\n    }\n    if (proto[zoneSymbolAddEventListener]) {\n      return false;\n    }\n    const eventNameToString = patchOptions2 && patchOptions2.eventNameToString;\n    const taskData = {};\n    const nativeAddEventListener = proto[zoneSymbolAddEventListener] = proto[ADD_EVENT_LISTENER];\n    const nativeRemoveEventListener = proto[zoneSymbol(REMOVE_EVENT_LISTENER)] = proto[REMOVE_EVENT_LISTENER];\n    const nativeListeners = proto[zoneSymbol(LISTENERS_EVENT_LISTENER)] = proto[LISTENERS_EVENT_LISTENER];\n    const nativeRemoveAllListeners = proto[zoneSymbol(REMOVE_ALL_LISTENERS_EVENT_LISTENER)] = proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER];\n    let nativePrependEventListener;\n    if (patchOptions2 && patchOptions2.prepend) {\n      nativePrependEventListener = proto[zoneSymbol(patchOptions2.prepend)] = proto[patchOptions2.prepend];\n    }\n    function buildEventListenerOptions(options, passive) {\n      if (!passive) {\n        return options;\n      }\n      if (typeof options === \"boolean\") {\n        return { capture: options, passive: true };\n      }\n      if (!options) {\n        return { passive: true };\n      }\n      if (typeof options === \"object\" && options.passive !== false) {\n        return __spreadProps(__spreadValues({}, options), { passive: true });\n      }\n      return options;\n    }\n    const customScheduleGlobal = function(task) {\n      if (taskData.isExisting) {\n        return;\n      }\n      return nativeAddEventListener.call(taskData.target, taskData.eventName, taskData.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, taskData.options);\n    };\n    const customCancelGlobal = function(task) {\n      if (!task.isRemoved) {\n        const symbolEventNames = zoneSymbolEventNames2[task.eventName];\n        let symbolEventName;\n        if (symbolEventNames) {\n          symbolEventName = symbolEventNames[task.capture ? TRUE_STR : FALSE_STR];\n        }\n        const existingTasks = symbolEventName && task.target[symbolEventName];\n        if (existingTasks) {\n          for (let i = 0; i < existingTasks.length; i++) {\n            const existingTask = existingTasks[i];\n            if (existingTask === task) {\n              existingTasks.splice(i, 1);\n              task.isRemoved = true;\n              if (task.removeAbortListener) {\n                task.removeAbortListener();\n                task.removeAbortListener = null;\n              }\n              if (existingTasks.length === 0) {\n                task.allRemoved = true;\n                task.target[symbolEventName] = null;\n              }\n              break;\n            }\n          }\n        }\n      }\n      if (!task.allRemoved) {\n        return;\n      }\n      return nativeRemoveEventListener.call(task.target, task.eventName, task.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, task.options);\n    };\n    const customScheduleNonGlobal = function(task) {\n      return nativeAddEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);\n    };\n    const customSchedulePrepend = function(task) {\n      return nativePrependEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);\n    };\n    const customCancelNonGlobal = function(task) {\n      return nativeRemoveEventListener.call(task.target, task.eventName, task.invoke, task.options);\n    };\n    const customSchedule = useGlobalCallback ? customScheduleGlobal : customScheduleNonGlobal;\n    const customCancel = useGlobalCallback ? customCancelGlobal : customCancelNonGlobal;\n    const compareTaskCallbackVsDelegate = function(task, delegate) {\n      const typeOfDelegate = typeof delegate;\n      return typeOfDelegate === \"function\" && task.callback === delegate || typeOfDelegate === \"object\" && task.originalDelegate === delegate;\n    };\n    const compare = (patchOptions2 == null ? void 0 : patchOptions2.diff) || compareTaskCallbackVsDelegate;\n    const unpatchedEvents = Zone[zoneSymbol(\"UNPATCHED_EVENTS\")];\n    const passiveEvents = _global2[zoneSymbol(\"PASSIVE_EVENTS\")];\n    function copyEventListenerOptions(options) {\n      if (typeof options === \"object\" && options !== null) {\n        const newOptions = __spreadValues({}, options);\n        if (options.signal) {\n          newOptions.signal = options.signal;\n        }\n        return newOptions;\n      }\n      return options;\n    }\n    const makeAddListener = function(nativeListener, addSource, customScheduleFn, customCancelFn, returnTarget2 = false, prepend = false) {\n      return function() {\n        const target = this || _global2;\n        let eventName = arguments[0];\n        if (patchOptions2 && patchOptions2.transferEventName) {\n          eventName = patchOptions2.transferEventName(eventName);\n        }\n        let delegate = arguments[1];\n        if (!delegate) {\n          return nativeListener.apply(this, arguments);\n        }\n        if (isNode && eventName === \"uncaughtException\") {\n          return nativeListener.apply(this, arguments);\n        }\n        let isEventListenerObject = false;\n        if (typeof delegate !== \"function\") {\n          if (!delegate.handleEvent) {\n            return nativeListener.apply(this, arguments);\n          }\n          isEventListenerObject = true;\n        }\n        if (validateHandler && !validateHandler(nativeListener, delegate, target, arguments)) {\n          return;\n        }\n        const passive = !!passiveEvents && passiveEvents.indexOf(eventName) !== -1;\n        const options = copyEventListenerOptions(buildEventListenerOptions(arguments[2], passive));\n        const signal = options == null ? void 0 : options.signal;\n        if (signal == null ? void 0 : signal.aborted) {\n          return;\n        }\n        if (unpatchedEvents) {\n          for (let i = 0; i < unpatchedEvents.length; i++) {\n            if (eventName === unpatchedEvents[i]) {\n              if (passive) {\n                return nativeListener.call(target, eventName, delegate, options);\n              } else {\n                return nativeListener.apply(this, arguments);\n              }\n            }\n          }\n        }\n        const capture = !options ? false : typeof options === \"boolean\" ? true : options.capture;\n        const once = options && typeof options === \"object\" ? options.once : false;\n        const zone = Zone.current;\n        let symbolEventNames = zoneSymbolEventNames2[eventName];\n        if (!symbolEventNames) {\n          prepareEventNames(eventName, eventNameToString);\n          symbolEventNames = zoneSymbolEventNames2[eventName];\n        }\n        const symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];\n        let existingTasks = target[symbolEventName];\n        let isExisting = false;\n        if (existingTasks) {\n          isExisting = true;\n          if (checkDuplicate) {\n            for (let i = 0; i < existingTasks.length; i++) {\n              if (compare(existingTasks[i], delegate)) {\n                return;\n              }\n            }\n          }\n        } else {\n          existingTasks = target[symbolEventName] = [];\n        }\n        let source;\n        const constructorName = target.constructor[\"name\"];\n        const targetSource = globalSources[constructorName];\n        if (targetSource) {\n          source = targetSource[eventName];\n        }\n        if (!source) {\n          source = constructorName + addSource + (eventNameToString ? eventNameToString(eventName) : eventName);\n        }\n        taskData.options = options;\n        if (once) {\n          taskData.options.once = false;\n        }\n        taskData.target = target;\n        taskData.capture = capture;\n        taskData.eventName = eventName;\n        taskData.isExisting = isExisting;\n        const data = useGlobalCallback ? OPTIMIZED_ZONE_EVENT_TASK_DATA : void 0;\n        if (data) {\n          data.taskData = taskData;\n        }\n        if (signal) {\n          taskData.options.signal = void 0;\n        }\n        const task = zone.scheduleEventTask(source, delegate, data, customScheduleFn, customCancelFn);\n        if (signal) {\n          taskData.options.signal = signal;\n          const onAbort = () => task.zone.cancelTask(task);\n          nativeListener.call(signal, \"abort\", onAbort, { once: true });\n          task.removeAbortListener = () => signal.removeEventListener(\"abort\", onAbort);\n        }\n        taskData.target = null;\n        if (data) {\n          data.taskData = null;\n        }\n        if (once) {\n          taskData.options.once = true;\n        }\n        if (typeof task.options !== \"boolean\") {\n          task.options = options;\n        }\n        task.target = target;\n        task.capture = capture;\n        task.eventName = eventName;\n        if (isEventListenerObject) {\n          task.originalDelegate = delegate;\n        }\n        if (!prepend) {\n          existingTasks.push(task);\n        } else {\n          existingTasks.unshift(task);\n        }\n        if (returnTarget2) {\n          return target;\n        }\n      };\n    };\n    proto[ADD_EVENT_LISTENER] = makeAddListener(nativeAddEventListener, ADD_EVENT_LISTENER_SOURCE, customSchedule, customCancel, returnTarget);\n    if (nativePrependEventListener) {\n      proto[PREPEND_EVENT_LISTENER] = makeAddListener(nativePrependEventListener, PREPEND_EVENT_LISTENER_SOURCE, customSchedulePrepend, customCancel, returnTarget, true);\n    }\n    proto[REMOVE_EVENT_LISTENER] = function() {\n      const target = this || _global2;\n      let eventName = arguments[0];\n      if (patchOptions2 && patchOptions2.transferEventName) {\n        eventName = patchOptions2.transferEventName(eventName);\n      }\n      const options = arguments[2];\n      const capture = !options ? false : typeof options === \"boolean\" ? true : options.capture;\n      const delegate = arguments[1];\n      if (!delegate) {\n        return nativeRemoveEventListener.apply(this, arguments);\n      }\n      if (validateHandler && !validateHandler(nativeRemoveEventListener, delegate, target, arguments)) {\n        return;\n      }\n      const symbolEventNames = zoneSymbolEventNames2[eventName];\n      let symbolEventName;\n      if (symbolEventNames) {\n        symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];\n      }\n      const existingTasks = symbolEventName && target[symbolEventName];\n      if (existingTasks) {\n        for (let i = 0; i < existingTasks.length; i++) {\n          const existingTask = existingTasks[i];\n          if (compare(existingTask, delegate)) {\n            existingTasks.splice(i, 1);\n            existingTask.isRemoved = true;\n            if (existingTasks.length === 0) {\n              existingTask.allRemoved = true;\n              target[symbolEventName] = null;\n              if (!capture && typeof eventName === \"string\") {\n                const onPropertySymbol = ZONE_SYMBOL_PREFIX + \"ON_PROPERTY\" + eventName;\n                target[onPropertySymbol] = null;\n              }\n            }\n            existingTask.zone.cancelTask(existingTask);\n            if (returnTarget) {\n              return target;\n            }\n            return;\n          }\n        }\n      }\n      return nativeRemoveEventListener.apply(this, arguments);\n    };\n    proto[LISTENERS_EVENT_LISTENER] = function() {\n      const target = this || _global2;\n      let eventName = arguments[0];\n      if (patchOptions2 && patchOptions2.transferEventName) {\n        eventName = patchOptions2.transferEventName(eventName);\n      }\n      const listeners = [];\n      const tasks = findEventTasks(target, eventNameToString ? eventNameToString(eventName) : eventName);\n      for (let i = 0; i < tasks.length; i++) {\n        const task = tasks[i];\n        let delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n        listeners.push(delegate);\n      }\n      return listeners;\n    };\n    proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER] = function() {\n      const target = this || _global2;\n      let eventName = arguments[0];\n      if (!eventName) {\n        const keys = Object.keys(target);\n        for (let i = 0; i < keys.length; i++) {\n          const prop = keys[i];\n          const match = EVENT_NAME_SYMBOL_REGX.exec(prop);\n          let evtName = match && match[1];\n          if (evtName && evtName !== \"removeListener\") {\n            this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, evtName);\n          }\n        }\n        this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, \"removeListener\");\n      } else {\n        if (patchOptions2 && patchOptions2.transferEventName) {\n          eventName = patchOptions2.transferEventName(eventName);\n        }\n        const symbolEventNames = zoneSymbolEventNames2[eventName];\n        if (symbolEventNames) {\n          const symbolEventName = symbolEventNames[FALSE_STR];\n          const symbolCaptureEventName = symbolEventNames[TRUE_STR];\n          const tasks = target[symbolEventName];\n          const captureTasks = target[symbolCaptureEventName];\n          if (tasks) {\n            const removeTasks = tasks.slice();\n            for (let i = 0; i < removeTasks.length; i++) {\n              const task = removeTasks[i];\n              let delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n              this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);\n            }\n          }\n          if (captureTasks) {\n            const removeTasks = captureTasks.slice();\n            for (let i = 0; i < removeTasks.length; i++) {\n              const task = removeTasks[i];\n              let delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n              this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);\n            }\n          }\n        }\n      }\n      if (returnTarget) {\n        return this;\n      }\n    };\n    attachOriginToPatched(proto[ADD_EVENT_LISTENER], nativeAddEventListener);\n    attachOriginToPatched(proto[REMOVE_EVENT_LISTENER], nativeRemoveEventListener);\n    if (nativeRemoveAllListeners) {\n      attachOriginToPatched(proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER], nativeRemoveAllListeners);\n    }\n    if (nativeListeners) {\n      attachOriginToPatched(proto[LISTENERS_EVENT_LISTENER], nativeListeners);\n    }\n    return true;\n  }\n  let results = [];\n  for (let i = 0; i < apis.length; i++) {\n    results[i] = patchEventTargetMethods(apis[i], patchOptions);\n  }\n  return results;\n}\nfunction findEventTasks(target, eventName) {\n  if (!eventName) {\n    const foundTasks = [];\n    for (let prop in target) {\n      const match = EVENT_NAME_SYMBOL_REGX.exec(prop);\n      let evtName = match && match[1];\n      if (evtName && (!eventName || evtName === eventName)) {\n        const tasks = target[prop];\n        if (tasks) {\n          for (let i = 0; i < tasks.length; i++) {\n            foundTasks.push(tasks[i]);\n          }\n        }\n      }\n    }\n    return foundTasks;\n  }\n  let symbolEventName = zoneSymbolEventNames2[eventName];\n  if (!symbolEventName) {\n    prepareEventNames(eventName);\n    symbolEventName = zoneSymbolEventNames2[eventName];\n  }\n  const captureFalseTasks = target[symbolEventName[FALSE_STR]];\n  const captureTrueTasks = target[symbolEventName[TRUE_STR]];\n  if (!captureFalseTasks) {\n    return captureTrueTasks ? captureTrueTasks.slice() : [];\n  } else {\n    return captureTrueTasks ? captureFalseTasks.concat(captureTrueTasks) : captureFalseTasks.slice();\n  }\n}\nfunction patchEventPrototype(global2, api) {\n  const Event = global2[\"Event\"];\n  if (Event && Event.prototype) {\n    api.patchMethod(Event.prototype, \"stopImmediatePropagation\", (delegate) => function(self2, args) {\n      self2[IMMEDIATE_PROPAGATION_SYMBOL] = true;\n      delegate && delegate.apply(self2, args);\n    });\n  }\n}\n\n// packages/zone.js/lib/common/queue-microtask.js\nfunction patchQueueMicrotask(global2, api) {\n  api.patchMethod(global2, \"queueMicrotask\", (delegate) => {\n    return function(self2, args) {\n      Zone.current.scheduleMicroTask(\"queueMicrotask\", args[0]);\n    };\n  });\n}\n\n// packages/zone.js/lib/common/timers.js\nvar taskSymbol = zoneSymbol(\"zoneTask\");\nfunction patchTimer(window2, setName, cancelName, nameSuffix) {\n  let setNative = null;\n  let clearNative = null;\n  setName += nameSuffix;\n  cancelName += nameSuffix;\n  const tasksByHandleId = {};\n  function scheduleTask(task) {\n    const data = task.data;\n    data.args[0] = function() {\n      return task.invoke.apply(this, arguments);\n    };\n    const handleOrId = setNative.apply(window2, data.args);\n    if (isNumber(handleOrId)) {\n      data.handleId = handleOrId;\n    } else {\n      data.handle = handleOrId;\n      data.isRefreshable = isFunction(handleOrId.refresh);\n    }\n    return task;\n  }\n  function clearTask(task) {\n    const { handle, handleId } = task.data;\n    return clearNative.call(window2, handle != null ? handle : handleId);\n  }\n  setNative = patchMethod(window2, setName, (delegate) => function(self2, args) {\n    var _a;\n    if (isFunction(args[0])) {\n      const options = {\n        isRefreshable: false,\n        isPeriodic: nameSuffix === \"Interval\",\n        delay: nameSuffix === \"Timeout\" || nameSuffix === \"Interval\" ? args[1] || 0 : void 0,\n        args\n      };\n      const callback = args[0];\n      args[0] = function timer() {\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          const { handle: handle2, handleId: handleId2, isPeriodic: isPeriodic2, isRefreshable: isRefreshable2 } = options;\n          if (!isPeriodic2 && !isRefreshable2) {\n            if (handleId2) {\n              delete tasksByHandleId[handleId2];\n            } else if (handle2) {\n              handle2[taskSymbol] = null;\n            }\n          }\n        }\n      };\n      const task = scheduleMacroTaskWithCurrentZone(setName, args[0], options, scheduleTask, clearTask);\n      if (!task) {\n        return task;\n      }\n      const { handleId, handle, isRefreshable, isPeriodic } = task.data;\n      if (handleId) {\n        tasksByHandleId[handleId] = task;\n      } else if (handle) {\n        handle[taskSymbol] = task;\n        if (isRefreshable && !isPeriodic) {\n          const originalRefresh = handle.refresh;\n          handle.refresh = function() {\n            const { zone, state } = task;\n            if (state === \"notScheduled\") {\n              task._state = \"scheduled\";\n              zone._updateTaskCount(task, 1);\n            } else if (state === \"running\") {\n              task._state = \"scheduling\";\n            }\n            return originalRefresh.call(this);\n          };\n        }\n      }\n      return (_a = handle != null ? handle : handleId) != null ? _a : task;\n    } else {\n      return delegate.apply(window2, args);\n    }\n  });\n  clearNative = patchMethod(window2, cancelName, (delegate) => function(self2, args) {\n    const id = args[0];\n    let task;\n    if (isNumber(id)) {\n      task = tasksByHandleId[id];\n      delete tasksByHandleId[id];\n    } else {\n      task = id == null ? void 0 : id[taskSymbol];\n      if (task) {\n        id[taskSymbol] = null;\n      } else {\n        task = id;\n      }\n    }\n    if (task == null ? void 0 : task.type) {\n      if (task.cancelFn) {\n        task.zone.cancelTask(task);\n      }\n    } else {\n      delegate.apply(window2, args);\n    }\n  });\n}\n\n// packages/zone.js/lib/browser/custom-elements.js\nfunction patchCustomElements(_global2, api) {\n  const { isBrowser: isBrowser2, isMix: isMix2 } = api.getGlobalObjects();\n  if (!isBrowser2 && !isMix2 || !_global2[\"customElements\"] || !(\"customElements\" in _global2)) {\n    return;\n  }\n  const callbacks = [\n    \"connectedCallback\",\n    \"disconnectedCallback\",\n    \"adoptedCallback\",\n    \"attributeChangedCallback\",\n    \"formAssociatedCallback\",\n    \"formDisabledCallback\",\n    \"formResetCallback\",\n    \"formStateRestoreCallback\"\n  ];\n  api.patchCallbacks(api, _global2.customElements, \"customElements\", \"define\", callbacks);\n}\n\n// packages/zone.js/lib/browser/event-target.js\nfunction eventTargetPatch(_global2, api) {\n  if (Zone[api.symbol(\"patchEventTarget\")]) {\n    return;\n  }\n  const { eventNames, zoneSymbolEventNames: zoneSymbolEventNames3, TRUE_STR: TRUE_STR2, FALSE_STR: FALSE_STR2, ZONE_SYMBOL_PREFIX: ZONE_SYMBOL_PREFIX2 } = api.getGlobalObjects();\n  for (let i = 0; i < eventNames.length; i++) {\n    const eventName = eventNames[i];\n    const falseEventName = eventName + FALSE_STR2;\n    const trueEventName = eventName + TRUE_STR2;\n    const symbol = ZONE_SYMBOL_PREFIX2 + falseEventName;\n    const symbolCapture = ZONE_SYMBOL_PREFIX2 + trueEventName;\n    zoneSymbolEventNames3[eventName] = {};\n    zoneSymbolEventNames3[eventName][FALSE_STR2] = symbol;\n    zoneSymbolEventNames3[eventName][TRUE_STR2] = symbolCapture;\n  }\n  const EVENT_TARGET = _global2[\"EventTarget\"];\n  if (!EVENT_TARGET || !EVENT_TARGET.prototype) {\n    return;\n  }\n  api.patchEventTarget(_global2, api, [EVENT_TARGET && EVENT_TARGET.prototype]);\n  return true;\n}\nfunction patchEvent(global2, api) {\n  api.patchEventPrototype(global2, api);\n}\n\n// packages/zone.js/lib/browser/property-descriptor.js\nfunction filterProperties(target, onProperties, ignoreProperties) {\n  if (!ignoreProperties || ignoreProperties.length === 0) {\n    return onProperties;\n  }\n  const tip = ignoreProperties.filter((ip) => ip.target === target);\n  if (tip.length === 0) {\n    return onProperties;\n  }\n  const targetIgnoreProperties = tip[0].ignoreProperties;\n  return onProperties.filter((op) => targetIgnoreProperties.indexOf(op) === -1);\n}\nfunction patchFilteredProperties(target, onProperties, ignoreProperties, prototype) {\n  if (!target) {\n    return;\n  }\n  const filteredProperties = filterProperties(target, onProperties, ignoreProperties);\n  patchOnProperties(target, filteredProperties, prototype);\n}\nfunction getOnEventNames(target) {\n  return Object.getOwnPropertyNames(target).filter((name) => name.startsWith(\"on\") && name.length > 2).map((name) => name.substring(2));\n}\nfunction propertyDescriptorPatch(api, _global2) {\n  if (isNode && !isMix) {\n    return;\n  }\n  if (Zone[api.symbol(\"patchEvents\")]) {\n    return;\n  }\n  const ignoreProperties = _global2[\"__Zone_ignore_on_properties\"];\n  let patchTargets = [];\n  if (isBrowser) {\n    const internalWindow2 = window;\n    patchTargets = patchTargets.concat([\n      \"Document\",\n      \"SVGElement\",\n      \"Element\",\n      \"HTMLElement\",\n      \"HTMLBodyElement\",\n      \"HTMLMediaElement\",\n      \"HTMLFrameSetElement\",\n      \"HTMLFrameElement\",\n      \"HTMLIFrameElement\",\n      \"HTMLMarqueeElement\",\n      \"Worker\"\n    ]);\n    patchFilteredProperties(internalWindow2, getOnEventNames(internalWindow2), ignoreProperties, ObjectGetPrototypeOf(internalWindow2));\n  }\n  patchTargets = patchTargets.concat([\n    \"XMLHttpRequest\",\n    \"XMLHttpRequestEventTarget\",\n    \"IDBIndex\",\n    \"IDBRequest\",\n    \"IDBOpenDBRequest\",\n    \"IDBDatabase\",\n    \"IDBTransaction\",\n    \"IDBCursor\",\n    \"WebSocket\"\n  ]);\n  for (let i = 0; i < patchTargets.length; i++) {\n    const target = _global2[patchTargets[i]];\n    (target == null ? void 0 : target.prototype) && patchFilteredProperties(target.prototype, getOnEventNames(target.prototype), ignoreProperties);\n  }\n}\n\n// packages/zone.js/lib/browser/browser.js\nfunction patchBrowser(Zone3) {\n  Zone3.__load_patch(\"timers\", (global2) => {\n    const set = \"set\";\n    const clear = \"clear\";\n    patchTimer(global2, set, clear, \"Timeout\");\n    patchTimer(global2, set, clear, \"Interval\");\n    patchTimer(global2, set, clear, \"Immediate\");\n  });\n  Zone3.__load_patch(\"requestAnimationFrame\", (global2) => {\n    patchTimer(global2, \"request\", \"cancel\", \"AnimationFrame\");\n    patchTimer(global2, \"mozRequest\", \"mozCancel\", \"AnimationFrame\");\n    patchTimer(global2, \"webkitRequest\", \"webkitCancel\", \"AnimationFrame\");\n  });\n  Zone3.__load_patch(\"blocking\", (global2, Zone4) => {\n    const blockingMethods = [\"alert\", \"prompt\", \"confirm\"];\n    for (let i = 0; i < blockingMethods.length; i++) {\n      const name = blockingMethods[i];\n      patchMethod(global2, name, (delegate, symbol, name2) => {\n        return function(s, args) {\n          return Zone4.current.run(delegate, global2, args, name2);\n        };\n      });\n    }\n  });\n  Zone3.__load_patch(\"EventTarget\", (global2, Zone4, api) => {\n    patchEvent(global2, api);\n    eventTargetPatch(global2, api);\n    const XMLHttpRequestEventTarget = global2[\"XMLHttpRequestEventTarget\"];\n    if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {\n      api.patchEventTarget(global2, api, [XMLHttpRequestEventTarget.prototype]);\n    }\n  });\n  Zone3.__load_patch(\"MutationObserver\", (global2, Zone4, api) => {\n    patchClass(\"MutationObserver\");\n    patchClass(\"WebKitMutationObserver\");\n  });\n  Zone3.__load_patch(\"IntersectionObserver\", (global2, Zone4, api) => {\n    patchClass(\"IntersectionObserver\");\n  });\n  Zone3.__load_patch(\"FileReader\", (global2, Zone4, api) => {\n    patchClass(\"FileReader\");\n  });\n  Zone3.__load_patch(\"on_property\", (global2, Zone4, api) => {\n    propertyDescriptorPatch(api, global2);\n  });\n  Zone3.__load_patch(\"customElements\", (global2, Zone4, api) => {\n    patchCustomElements(global2, api);\n  });\n  Zone3.__load_patch(\"XHR\", (global2, Zone4) => {\n    patchXHR(global2);\n    const XHR_TASK = zoneSymbol(\"xhrTask\");\n    const XHR_SYNC = zoneSymbol(\"xhrSync\");\n    const XHR_LISTENER = zoneSymbol(\"xhrListener\");\n    const XHR_SCHEDULED = zoneSymbol(\"xhrScheduled\");\n    const XHR_URL = zoneSymbol(\"xhrURL\");\n    const XHR_ERROR_BEFORE_SCHEDULED = zoneSymbol(\"xhrErrorBeforeScheduled\");\n    function patchXHR(window2) {\n      const XMLHttpRequest = window2[\"XMLHttpRequest\"];\n      if (!XMLHttpRequest) {\n        return;\n      }\n      const XMLHttpRequestPrototype = XMLHttpRequest.prototype;\n      function findPendingTask(target) {\n        return target[XHR_TASK];\n      }\n      let oriAddListener = XMLHttpRequestPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];\n      let oriRemoveListener = XMLHttpRequestPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\n      if (!oriAddListener) {\n        const XMLHttpRequestEventTarget = window2[\"XMLHttpRequestEventTarget\"];\n        if (XMLHttpRequestEventTarget) {\n          const XMLHttpRequestEventTargetPrototype = XMLHttpRequestEventTarget.prototype;\n          oriAddListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];\n          oriRemoveListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\n        }\n      }\n      const READY_STATE_CHANGE = \"readystatechange\";\n      const SCHEDULED = \"scheduled\";\n      function scheduleTask(task) {\n        const data = task.data;\n        const target = data.target;\n        target[XHR_SCHEDULED] = false;\n        target[XHR_ERROR_BEFORE_SCHEDULED] = false;\n        const listener = target[XHR_LISTENER];\n        if (!oriAddListener) {\n          oriAddListener = target[ZONE_SYMBOL_ADD_EVENT_LISTENER];\n          oriRemoveListener = target[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\n        }\n        if (listener) {\n          oriRemoveListener.call(target, READY_STATE_CHANGE, listener);\n        }\n        const newListener = target[XHR_LISTENER] = () => {\n          if (target.readyState === target.DONE) {\n            if (!data.aborted && target[XHR_SCHEDULED] && task.state === SCHEDULED) {\n              const loadTasks = target[Zone4.__symbol__(\"loadfalse\")];\n              if (target.status !== 0 && loadTasks && loadTasks.length > 0) {\n                const oriInvoke = task.invoke;\n                task.invoke = function() {\n                  const loadTasks2 = target[Zone4.__symbol__(\"loadfalse\")];\n                  for (let i = 0; i < loadTasks2.length; i++) {\n                    if (loadTasks2[i] === task) {\n                      loadTasks2.splice(i, 1);\n                    }\n                  }\n                  if (!data.aborted && task.state === SCHEDULED) {\n                    oriInvoke.call(task);\n                  }\n                };\n                loadTasks.push(task);\n              } else {\n                task.invoke();\n              }\n            } else if (!data.aborted && target[XHR_SCHEDULED] === false) {\n              target[XHR_ERROR_BEFORE_SCHEDULED] = true;\n            }\n          }\n        };\n        oriAddListener.call(target, READY_STATE_CHANGE, newListener);\n        const storedTask = target[XHR_TASK];\n        if (!storedTask) {\n          target[XHR_TASK] = task;\n        }\n        sendNative.apply(target, data.args);\n        target[XHR_SCHEDULED] = true;\n        return task;\n      }\n      function placeholderCallback() {\n      }\n      function clearTask(task) {\n        const data = task.data;\n        data.aborted = true;\n        return abortNative.apply(data.target, data.args);\n      }\n      const openNative = patchMethod(XMLHttpRequestPrototype, \"open\", () => function(self2, args) {\n        self2[XHR_SYNC] = args[2] == false;\n        self2[XHR_URL] = args[1];\n        return openNative.apply(self2, args);\n      });\n      const XMLHTTPREQUEST_SOURCE = \"XMLHttpRequest.send\";\n      const fetchTaskAborting = zoneSymbol(\"fetchTaskAborting\");\n      const fetchTaskScheduling = zoneSymbol(\"fetchTaskScheduling\");\n      const sendNative = patchMethod(XMLHttpRequestPrototype, \"send\", () => function(self2, args) {\n        if (Zone4.current[fetchTaskScheduling] === true) {\n          return sendNative.apply(self2, args);\n        }\n        if (self2[XHR_SYNC]) {\n          return sendNative.apply(self2, args);\n        } else {\n          const options = {\n            target: self2,\n            url: self2[XHR_URL],\n            isPeriodic: false,\n            args,\n            aborted: false\n          };\n          const task = scheduleMacroTaskWithCurrentZone(XMLHTTPREQUEST_SOURCE, placeholderCallback, options, scheduleTask, clearTask);\n          if (self2 && self2[XHR_ERROR_BEFORE_SCHEDULED] === true && !options.aborted && task.state === SCHEDULED) {\n            task.invoke();\n          }\n        }\n      });\n      const abortNative = patchMethod(XMLHttpRequestPrototype, \"abort\", () => function(self2, args) {\n        const task = findPendingTask(self2);\n        if (task && typeof task.type == \"string\") {\n          if (task.cancelFn == null || task.data && task.data.aborted) {\n            return;\n          }\n          task.zone.cancelTask(task);\n        } else if (Zone4.current[fetchTaskAborting] === true) {\n          return abortNative.apply(self2, args);\n        }\n      });\n    }\n  });\n  Zone3.__load_patch(\"geolocation\", (global2) => {\n    if (global2[\"navigator\"] && global2[\"navigator\"].geolocation) {\n      patchPrototype(global2[\"navigator\"].geolocation, [\"getCurrentPosition\", \"watchPosition\"]);\n    }\n  });\n  Zone3.__load_patch(\"PromiseRejectionEvent\", (global2, Zone4) => {\n    function findPromiseRejectionHandler(evtName) {\n      return function(e) {\n        const eventTasks = findEventTasks(global2, evtName);\n        eventTasks.forEach((eventTask) => {\n          const PromiseRejectionEvent = global2[\"PromiseRejectionEvent\"];\n          if (PromiseRejectionEvent) {\n            const evt = new PromiseRejectionEvent(evtName, {\n              promise: e.promise,\n              reason: e.rejection\n            });\n            eventTask.invoke(evt);\n          }\n        });\n      };\n    }\n    if (global2[\"PromiseRejectionEvent\"]) {\n      Zone4[zoneSymbol(\"unhandledPromiseRejectionHandler\")] = findPromiseRejectionHandler(\"unhandledrejection\");\n      Zone4[zoneSymbol(\"rejectionHandledHandler\")] = findPromiseRejectionHandler(\"rejectionhandled\");\n    }\n  });\n  Zone3.__load_patch(\"queueMicrotask\", (global2, Zone4, api) => {\n    patchQueueMicrotask(global2, api);\n  });\n}\n\n// packages/zone.js/lib/common/promise.js\nfunction patchPromise(Zone3) {\n  Zone3.__load_patch(\"ZoneAwarePromise\", (global2, Zone4, api) => {\n    const ObjectGetOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;\n    const ObjectDefineProperty2 = Object.defineProperty;\n    function readableObjectToString(obj) {\n      if (obj && obj.toString === Object.prototype.toString) {\n        const className = obj.constructor && obj.constructor.name;\n        return (className ? className : \"\") + \": \" + JSON.stringify(obj);\n      }\n      return obj ? obj.toString() : Object.prototype.toString.call(obj);\n    }\n    const __symbol__2 = api.symbol;\n    const _uncaughtPromiseErrors = [];\n    const isDisableWrappingUncaughtPromiseRejection = global2[__symbol__2(\"DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION\")] !== false;\n    const symbolPromise = __symbol__2(\"Promise\");\n    const symbolThen = __symbol__2(\"then\");\n    const creationTrace = \"__creationTrace__\";\n    api.onUnhandledError = (e) => {\n      if (api.showUncaughtError()) {\n        const rejection = e && e.rejection;\n        if (rejection) {\n          console.error(\"Unhandled Promise rejection:\", rejection instanceof Error ? rejection.message : rejection, \"; Zone:\", e.zone.name, \"; Task:\", e.task && e.task.source, \"; Value:\", rejection, rejection instanceof Error ? rejection.stack : void 0);\n        } else {\n          console.error(e);\n        }\n      }\n    };\n    api.microtaskDrainDone = () => {\n      while (_uncaughtPromiseErrors.length) {\n        const uncaughtPromiseError = _uncaughtPromiseErrors.shift();\n        try {\n          uncaughtPromiseError.zone.runGuarded(() => {\n            if (uncaughtPromiseError.throwOriginal) {\n              throw uncaughtPromiseError.rejection;\n            }\n            throw uncaughtPromiseError;\n          });\n        } catch (error) {\n          handleUnhandledRejection(error);\n        }\n      }\n    };\n    const UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL = __symbol__2(\"unhandledPromiseRejectionHandler\");\n    function handleUnhandledRejection(e) {\n      api.onUnhandledError(e);\n      try {\n        const handler = Zone4[UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL];\n        if (typeof handler === \"function\") {\n          handler.call(this, e);\n        }\n      } catch (err) {\n      }\n    }\n    function isThenable(value) {\n      return value && typeof value.then === \"function\";\n    }\n    function forwardResolution(value) {\n      return value;\n    }\n    function forwardRejection(rejection) {\n      return ZoneAwarePromise.reject(rejection);\n    }\n    const symbolState = __symbol__2(\"state\");\n    const symbolValue = __symbol__2(\"value\");\n    const symbolFinally = __symbol__2(\"finally\");\n    const symbolParentPromiseValue = __symbol__2(\"parentPromiseValue\");\n    const symbolParentPromiseState = __symbol__2(\"parentPromiseState\");\n    const source = \"Promise.then\";\n    const UNRESOLVED = null;\n    const RESOLVED = true;\n    const REJECTED = false;\n    const REJECTED_NO_CATCH = 0;\n    function makeResolver(promise, state) {\n      return (v) => {\n        try {\n          resolvePromise(promise, state, v);\n        } catch (err) {\n          resolvePromise(promise, false, err);\n        }\n      };\n    }\n    const once = function() {\n      let wasCalled = false;\n      return function wrapper(wrappedFunction) {\n        return function() {\n          if (wasCalled) {\n            return;\n          }\n          wasCalled = true;\n          wrappedFunction.apply(null, arguments);\n        };\n      };\n    };\n    const TYPE_ERROR = \"Promise resolved with itself\";\n    const CURRENT_TASK_TRACE_SYMBOL = __symbol__2(\"currentTaskTrace\");\n    function resolvePromise(promise, state, value) {\n      const onceWrapper = once();\n      if (promise === value) {\n        throw new TypeError(TYPE_ERROR);\n      }\n      if (promise[symbolState] === UNRESOLVED) {\n        let then = null;\n        try {\n          if (typeof value === \"object\" || typeof value === \"function\") {\n            then = value && value.then;\n          }\n        } catch (err) {\n          onceWrapper(() => {\n            resolvePromise(promise, false, err);\n          })();\n          return promise;\n        }\n        if (state !== REJECTED && value instanceof ZoneAwarePromise && value.hasOwnProperty(symbolState) && value.hasOwnProperty(symbolValue) && value[symbolState] !== UNRESOLVED) {\n          clearRejectedNoCatch(value);\n          resolvePromise(promise, value[symbolState], value[symbolValue]);\n        } else if (state !== REJECTED && typeof then === \"function\") {\n          try {\n            then.call(value, onceWrapper(makeResolver(promise, state)), onceWrapper(makeResolver(promise, false)));\n          } catch (err) {\n            onceWrapper(() => {\n              resolvePromise(promise, false, err);\n            })();\n          }\n        } else {\n          promise[symbolState] = state;\n          const queue = promise[symbolValue];\n          promise[symbolValue] = value;\n          if (promise[symbolFinally] === symbolFinally) {\n            if (state === RESOLVED) {\n              promise[symbolState] = promise[symbolParentPromiseState];\n              promise[symbolValue] = promise[symbolParentPromiseValue];\n            }\n          }\n          if (state === REJECTED && value instanceof Error) {\n            const trace = Zone4.currentTask && Zone4.currentTask.data && Zone4.currentTask.data[creationTrace];\n            if (trace) {\n              ObjectDefineProperty2(value, CURRENT_TASK_TRACE_SYMBOL, {\n                configurable: true,\n                enumerable: false,\n                writable: true,\n                value: trace\n              });\n            }\n          }\n          for (let i = 0; i < queue.length; ) {\n            scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);\n          }\n          if (queue.length == 0 && state == REJECTED) {\n            promise[symbolState] = REJECTED_NO_CATCH;\n            let uncaughtPromiseError = value;\n            try {\n              throw new Error(\"Uncaught (in promise): \" + readableObjectToString(value) + (value && value.stack ? \"\\n\" + value.stack : \"\"));\n            } catch (err) {\n              uncaughtPromiseError = err;\n            }\n            if (isDisableWrappingUncaughtPromiseRejection) {\n              uncaughtPromiseError.throwOriginal = true;\n            }\n            uncaughtPromiseError.rejection = value;\n            uncaughtPromiseError.promise = promise;\n            uncaughtPromiseError.zone = Zone4.current;\n            uncaughtPromiseError.task = Zone4.currentTask;\n            _uncaughtPromiseErrors.push(uncaughtPromiseError);\n            api.scheduleMicroTask();\n          }\n        }\n      }\n      return promise;\n    }\n    const REJECTION_HANDLED_HANDLER = __symbol__2(\"rejectionHandledHandler\");\n    function clearRejectedNoCatch(promise) {\n      if (promise[symbolState] === REJECTED_NO_CATCH) {\n        try {\n          const handler = Zone4[REJECTION_HANDLED_HANDLER];\n          if (handler && typeof handler === \"function\") {\n            handler.call(this, { rejection: promise[symbolValue], promise });\n          }\n        } catch (err) {\n        }\n        promise[symbolState] = REJECTED;\n        for (let i = 0; i < _uncaughtPromiseErrors.length; i++) {\n          if (promise === _uncaughtPromiseErrors[i].promise) {\n            _uncaughtPromiseErrors.splice(i, 1);\n          }\n        }\n      }\n    }\n    function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {\n      clearRejectedNoCatch(promise);\n      const promiseState = promise[symbolState];\n      const delegate = promiseState ? typeof onFulfilled === \"function\" ? onFulfilled : forwardResolution : typeof onRejected === \"function\" ? onRejected : forwardRejection;\n      zone.scheduleMicroTask(source, () => {\n        try {\n          const parentPromiseValue = promise[symbolValue];\n          const isFinallyPromise = !!chainPromise && symbolFinally === chainPromise[symbolFinally];\n          if (isFinallyPromise) {\n            chainPromise[symbolParentPromiseValue] = parentPromiseValue;\n            chainPromise[symbolParentPromiseState] = promiseState;\n          }\n          const value = zone.run(delegate, void 0, isFinallyPromise && delegate !== forwardRejection && delegate !== forwardResolution ? [] : [parentPromiseValue]);\n          resolvePromise(chainPromise, true, value);\n        } catch (error) {\n          resolvePromise(chainPromise, false, error);\n        }\n      }, chainPromise);\n    }\n    const ZONE_AWARE_PROMISE_TO_STRING = \"function ZoneAwarePromise() { [native code] }\";\n    const noop = function() {\n    };\n    const AggregateError = global2.AggregateError;\n    class ZoneAwarePromise {\n      static toString() {\n        return ZONE_AWARE_PROMISE_TO_STRING;\n      }\n      static resolve(value) {\n        if (value instanceof ZoneAwarePromise) {\n          return value;\n        }\n        return resolvePromise(new this(null), RESOLVED, value);\n      }\n      static reject(error) {\n        return resolvePromise(new this(null), REJECTED, error);\n      }\n      static withResolvers() {\n        const result = {};\n        result.promise = new ZoneAwarePromise((res, rej) => {\n          result.resolve = res;\n          result.reject = rej;\n        });\n        return result;\n      }\n      static any(values) {\n        if (!values || typeof values[Symbol.iterator] !== \"function\") {\n          return Promise.reject(new AggregateError([], \"All promises were rejected\"));\n        }\n        const promises = [];\n        let count = 0;\n        try {\n          for (let v of values) {\n            count++;\n            promises.push(ZoneAwarePromise.resolve(v));\n          }\n        } catch (err) {\n          return Promise.reject(new AggregateError([], \"All promises were rejected\"));\n        }\n        if (count === 0) {\n          return Promise.reject(new AggregateError([], \"All promises were rejected\"));\n        }\n        let finished = false;\n        const errors = [];\n        return new ZoneAwarePromise((resolve, reject) => {\n          for (let i = 0; i < promises.length; i++) {\n            promises[i].then((v) => {\n              if (finished) {\n                return;\n              }\n              finished = true;\n              resolve(v);\n            }, (err) => {\n              errors.push(err);\n              count--;\n              if (count === 0) {\n                finished = true;\n                reject(new AggregateError(errors, \"All promises were rejected\"));\n              }\n            });\n          }\n        });\n      }\n      static race(values) {\n        let resolve;\n        let reject;\n        let promise = new this((res, rej) => {\n          resolve = res;\n          reject = rej;\n        });\n        function onResolve(value) {\n          resolve(value);\n        }\n        function onReject(error) {\n          reject(error);\n        }\n        for (let value of values) {\n          if (!isThenable(value)) {\n            value = this.resolve(value);\n          }\n          value.then(onResolve, onReject);\n        }\n        return promise;\n      }\n      static all(values) {\n        return ZoneAwarePromise.allWithCallback(values);\n      }\n      static allSettled(values) {\n        const P = this && this.prototype instanceof ZoneAwarePromise ? this : ZoneAwarePromise;\n        return P.allWithCallback(values, {\n          thenCallback: (value) => ({ status: \"fulfilled\", value }),\n          errorCallback: (err) => ({ status: \"rejected\", reason: err })\n        });\n      }\n      static allWithCallback(values, callback) {\n        let resolve;\n        let reject;\n        let promise = new this((res, rej) => {\n          resolve = res;\n          reject = rej;\n        });\n        let unresolvedCount = 2;\n        let valueIndex = 0;\n        const resolvedValues = [];\n        for (let value of values) {\n          if (!isThenable(value)) {\n            value = this.resolve(value);\n          }\n          const curValueIndex = valueIndex;\n          try {\n            value.then((value2) => {\n              resolvedValues[curValueIndex] = callback ? callback.thenCallback(value2) : value2;\n              unresolvedCount--;\n              if (unresolvedCount === 0) {\n                resolve(resolvedValues);\n              }\n            }, (err) => {\n              if (!callback) {\n                reject(err);\n              } else {\n                resolvedValues[curValueIndex] = callback.errorCallback(err);\n                unresolvedCount--;\n                if (unresolvedCount === 0) {\n                  resolve(resolvedValues);\n                }\n              }\n            });\n          } catch (thenErr) {\n            reject(thenErr);\n          }\n          unresolvedCount++;\n          valueIndex++;\n        }\n        unresolvedCount -= 2;\n        if (unresolvedCount === 0) {\n          resolve(resolvedValues);\n        }\n        return promise;\n      }\n      constructor(executor) {\n        const promise = this;\n        if (!(promise instanceof ZoneAwarePromise)) {\n          throw new Error(\"Must be an instanceof Promise.\");\n        }\n        promise[symbolState] = UNRESOLVED;\n        promise[symbolValue] = [];\n        try {\n          const onceWrapper = once();\n          executor && executor(onceWrapper(makeResolver(promise, RESOLVED)), onceWrapper(makeResolver(promise, REJECTED)));\n        } catch (error) {\n          resolvePromise(promise, false, error);\n        }\n      }\n      get [Symbol.toStringTag]() {\n        return \"Promise\";\n      }\n      get [Symbol.species]() {\n        return ZoneAwarePromise;\n      }\n      then(onFulfilled, onRejected) {\n        var _a;\n        let C = (_a = this.constructor) == null ? void 0 : _a[Symbol.species];\n        if (!C || typeof C !== \"function\") {\n          C = this.constructor || ZoneAwarePromise;\n        }\n        const chainPromise = new C(noop);\n        const zone = Zone4.current;\n        if (this[symbolState] == UNRESOLVED) {\n          this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);\n        } else {\n          scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);\n        }\n        return chainPromise;\n      }\n      catch(onRejected) {\n        return this.then(null, onRejected);\n      }\n      finally(onFinally) {\n        var _a;\n        let C = (_a = this.constructor) == null ? void 0 : _a[Symbol.species];\n        if (!C || typeof C !== \"function\") {\n          C = ZoneAwarePromise;\n        }\n        const chainPromise = new C(noop);\n        chainPromise[symbolFinally] = symbolFinally;\n        const zone = Zone4.current;\n        if (this[symbolState] == UNRESOLVED) {\n          this[symbolValue].push(zone, chainPromise, onFinally, onFinally);\n        } else {\n          scheduleResolveOrReject(this, zone, chainPromise, onFinally, onFinally);\n        }\n        return chainPromise;\n      }\n    }\n    ZoneAwarePromise[\"resolve\"] = ZoneAwarePromise.resolve;\n    ZoneAwarePromise[\"reject\"] = ZoneAwarePromise.reject;\n    ZoneAwarePromise[\"race\"] = ZoneAwarePromise.race;\n    ZoneAwarePromise[\"all\"] = ZoneAwarePromise.all;\n    const NativePromise = global2[symbolPromise] = global2[\"Promise\"];\n    global2[\"Promise\"] = ZoneAwarePromise;\n    const symbolThenPatched = __symbol__2(\"thenPatched\");\n    function patchThen(Ctor) {\n      const proto = Ctor.prototype;\n      const prop = ObjectGetOwnPropertyDescriptor2(proto, \"then\");\n      if (prop && (prop.writable === false || !prop.configurable)) {\n        return;\n      }\n      const originalThen = proto.then;\n      proto[symbolThen] = originalThen;\n      Ctor.prototype.then = function(onResolve, onReject) {\n        const wrapped = new ZoneAwarePromise((resolve, reject) => {\n          originalThen.call(this, resolve, reject);\n        });\n        return wrapped.then(onResolve, onReject);\n      };\n      Ctor[symbolThenPatched] = true;\n    }\n    api.patchThen = patchThen;\n    function zoneify(fn) {\n      return function(self2, args) {\n        let resultPromise = fn.apply(self2, args);\n        if (resultPromise instanceof ZoneAwarePromise) {\n          return resultPromise;\n        }\n        let ctor = resultPromise.constructor;\n        if (!ctor[symbolThenPatched]) {\n          patchThen(ctor);\n        }\n        return resultPromise;\n      };\n    }\n    if (NativePromise) {\n      patchThen(NativePromise);\n      patchMethod(global2, \"fetch\", (delegate) => zoneify(delegate));\n    }\n    Promise[Zone4.__symbol__(\"uncaughtPromiseErrors\")] = _uncaughtPromiseErrors;\n    return ZoneAwarePromise;\n  });\n}\n\n// packages/zone.js/lib/common/to-string.js\nfunction patchToString(Zone3) {\n  Zone3.__load_patch(\"toString\", (global2) => {\n    const originalFunctionToString = Function.prototype.toString;\n    const ORIGINAL_DELEGATE_SYMBOL = zoneSymbol(\"OriginalDelegate\");\n    const PROMISE_SYMBOL = zoneSymbol(\"Promise\");\n    const ERROR_SYMBOL = zoneSymbol(\"Error\");\n    const newFunctionToString = function toString() {\n      if (typeof this === \"function\") {\n        const originalDelegate = this[ORIGINAL_DELEGATE_SYMBOL];\n        if (originalDelegate) {\n          if (typeof originalDelegate === \"function\") {\n            return originalFunctionToString.call(originalDelegate);\n          } else {\n            return Object.prototype.toString.call(originalDelegate);\n          }\n        }\n        if (this === Promise) {\n          const nativePromise = global2[PROMISE_SYMBOL];\n          if (nativePromise) {\n            return originalFunctionToString.call(nativePromise);\n          }\n        }\n        if (this === Error) {\n          const nativeError = global2[ERROR_SYMBOL];\n          if (nativeError) {\n            return originalFunctionToString.call(nativeError);\n          }\n        }\n      }\n      return originalFunctionToString.call(this);\n    };\n    newFunctionToString[ORIGINAL_DELEGATE_SYMBOL] = originalFunctionToString;\n    Function.prototype.toString = newFunctionToString;\n    const originalObjectToString = Object.prototype.toString;\n    const PROMISE_OBJECT_TO_STRING = \"[object Promise]\";\n    Object.prototype.toString = function() {\n      if (typeof Promise === \"function\" && this instanceof Promise) {\n        return PROMISE_OBJECT_TO_STRING;\n      }\n      return originalObjectToString.call(this);\n    };\n  });\n}\n\n// packages/zone.js/lib/browser/browser-util.js\nfunction patchCallbacks(api, target, targetName, method, callbacks) {\n  const symbol = Zone.__symbol__(method);\n  if (target[symbol]) {\n    return;\n  }\n  const nativeDelegate = target[symbol] = target[method];\n  target[method] = function(name, opts, options) {\n    if (opts && opts.prototype) {\n      callbacks.forEach(function(callback) {\n        const source = `${targetName}.${method}::` + callback;\n        const prototype = opts.prototype;\n        try {\n          if (prototype.hasOwnProperty(callback)) {\n            const descriptor = api.ObjectGetOwnPropertyDescriptor(prototype, callback);\n            if (descriptor && descriptor.value) {\n              descriptor.value = api.wrapWithCurrentZone(descriptor.value, source);\n              api._redefineProperty(opts.prototype, callback, descriptor);\n            } else if (prototype[callback]) {\n              prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);\n            }\n          } else if (prototype[callback]) {\n            prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);\n          }\n        } catch (e) {\n        }\n      });\n    }\n    return nativeDelegate.call(target, name, opts, options);\n  };\n  api.attachOriginToPatched(target[method], nativeDelegate);\n}\n\n// packages/zone.js/lib/browser/api-util.js\nfunction patchUtil(Zone3) {\n  Zone3.__load_patch(\"util\", (global2, Zone4, api) => {\n    const eventNames = getOnEventNames(global2);\n    api.patchOnProperties = patchOnProperties;\n    api.patchMethod = patchMethod;\n    api.bindArguments = bindArguments;\n    api.patchMacroTask = patchMacroTask;\n    const SYMBOL_BLACK_LISTED_EVENTS = Zone4.__symbol__(\"BLACK_LISTED_EVENTS\");\n    const SYMBOL_UNPATCHED_EVENTS = Zone4.__symbol__(\"UNPATCHED_EVENTS\");\n    if (global2[SYMBOL_UNPATCHED_EVENTS]) {\n      global2[SYMBOL_BLACK_LISTED_EVENTS] = global2[SYMBOL_UNPATCHED_EVENTS];\n    }\n    if (global2[SYMBOL_BLACK_LISTED_EVENTS]) {\n      Zone4[SYMBOL_BLACK_LISTED_EVENTS] = Zone4[SYMBOL_UNPATCHED_EVENTS] = global2[SYMBOL_BLACK_LISTED_EVENTS];\n    }\n    api.patchEventPrototype = patchEventPrototype;\n    api.patchEventTarget = patchEventTarget;\n    api.ObjectDefineProperty = ObjectDefineProperty;\n    api.ObjectGetOwnPropertyDescriptor = ObjectGetOwnPropertyDescriptor;\n    api.ObjectCreate = ObjectCreate;\n    api.ArraySlice = ArraySlice;\n    api.patchClass = patchClass;\n    api.wrapWithCurrentZone = wrapWithCurrentZone;\n    api.filterProperties = filterProperties;\n    api.attachOriginToPatched = attachOriginToPatched;\n    api._redefineProperty = Object.defineProperty;\n    api.patchCallbacks = patchCallbacks;\n    api.getGlobalObjects = () => ({\n      globalSources,\n      zoneSymbolEventNames: zoneSymbolEventNames2,\n      eventNames,\n      isBrowser,\n      isMix,\n      isNode,\n      TRUE_STR,\n      FALSE_STR,\n      ZONE_SYMBOL_PREFIX,\n      ADD_EVENT_LISTENER_STR,\n      REMOVE_EVENT_LISTENER_STR\n    });\n  });\n}\n\n// packages/zone.js/lib/browser/rollup-common.js\nfunction patchCommon(Zone3) {\n  patchPromise(Zone3);\n  patchToString(Zone3);\n  patchUtil(Zone3);\n}\n\n// packages/zone.js/lib/browser/rollup-main.js\nvar Zone2 = loadZone();\npatchCommon(Zone2);\npatchBrowser(Zone2);\n"],"x_google_ignoreList":[0]}